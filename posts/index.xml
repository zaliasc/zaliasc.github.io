<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - zaliasc's Blog</title><link>http://example.org/posts/</link><description>All Posts | zaliasc's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>zaliasc@gmail.com (zaliasc)</managingEditor><webMaster>zaliasc@gmail.com (zaliasc)</webMaster><lastBuildDate>Fri, 29 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml"/><item><title>算法模板整理</title><link>http://example.org/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/</link><pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate><author>zaliasc</author><guid>http://example.org/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/</guid><description>STL vector 支持 size() empty() clear() 清空 front()/back() 数组头尾元素 push_back()/pop_back begin()/end() 首尾元素 支持字典序比较 pair first 第一个元素 second 第二个元素 string size()/length 返回长度 empty() clear() substr(a,b) 得到一个下标位a长度位b的子字符串 substr(a) 得</description></item><item><title>从DPU的产生与发展说起</title><link>http://example.org/posts/dpu/</link><pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate><author>zaliasc</author><guid>http://example.org/posts/dpu/</guid><description>Nvidia（英伟达）于2020年收购Mellanox公司（专注于提供IB网络、Ethernet网络产品，如ConnectX系列网卡），并在</description></item><item><title>Windows WSL安装</title><link>http://example.org/posts/wsl%E5%AE%89%E8%A3%85/</link><pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate><author>zaliasc</author><guid>http://example.org/posts/wsl%E5%AE%89%E8%A3%85/</guid><description>第 1 步，启用 WSL 以管理员身份打开 PowerShell 工具并运行以下命令 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 第 2 步，启用“虚拟机平台” WSL 2 需要启用 Windows 10 的 “虚拟机平台” 特性。它独立于 Hyp</description></item><item><title>排序算法总结</title><link>http://example.org/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 20 Jun 2020 00:00:00 +0000</pubDate><author>zaliasc</author><guid>http://example.org/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description><![CDATA[<p><strong>不稳定排序算法</strong></p>
<p>[堆排序]、[快速排序]、[希尔排序]、[直接选择排序]</p>
<p><strong>稳定排序算法</strong></p>
<p>[基数排序]、[冒泡排序]、[直接插入排序]、[折半插入排序]、[归并排序]</p>
<h3 id="1冒泡排序">1.冒泡排序</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">arry</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span><span class="n">i</span><span class="o">&lt;</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span> <span class="p">;</span><span class="n">j</span> <span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div>]]></description></item><item><title>二叉树遍历</title><link>http://example.org/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate><author>zaliasc</author><guid>http://example.org/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description><![CDATA[前序遍历 void preorder(Node * head){ if(head!=null) { cout &lt;&lt; head -&gt; val; preorder(head-&gt;left); preorder(head-&gt;right); } } void preorder(Node * head){ if(!head) return ; stack&lt;Node *&gt; s; s.push(head); while(!s.empty()){ Node * tmp = s.top(); s.pop(); cout &lt;&lt; tmp.val; if(tmp-&gt;left) s.push(tmp-&gt;left); if(tmp-&gt;right) s.push(tmp-&gt;right); } } 中序遍历 void inorder(Node * head){ if(head!=null) { inorder(head-&gt;left); cout &lt;&lt; head -&gt; val; inorder(head-&gt;right); } } void inorder(Node * he]]></description></item></channel></rss>