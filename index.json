[{"categories":null,"content":"STL vector 支持 size() empty() clear() 清空 front()/back() 数组头尾元素 push_back()/pop_back begin()/end() 首尾元素 支持字典序比较 pair first 第一个元素 second 第二个元素 string size()/length 返回长度 empty() clear() substr(a,b) 得到一个下标位a长度位b的子字符串 substr(a) 得到一个下表为a长度取最长的子字符串 c_str() 取string定义数组的首地址 queue size() empty() push() 在队尾插入一个元素 front()/back() 返回队头/队尾元素 pop() 弹出队头元素 priority_queue 优先队列(堆) 默认大根堆 size() empty() push() top() pop() 定义小根堆: priority_queue\u003cint , vector\u003cint\u003e , greater\u003cint\u003e\u003e stack size() empty() push() pop() top() deque 支持[] size() empty() clear() front()/back() 头尾元素 push_back()/push_front() 在头尾插入 begin()/end() set , map , multimap , multiset , 基于平衡二叉树 (红黑树) 维护一个有序数列 大部分函数时间复杂度都是logn (因为是树) size() empty() clear() begin()/end() 支持++ -- 时间复杂度 O(logn) lower_bound()/upper_bound() lower_bound(x) 返回一个大于等于x的最小值 upper_bound(x) 返回一个大于x的最小值 set / multiset set不支持重复数插入 插入重复数直接跳过 insert() 插入一个数 find() 查找一个数 count() 返回一个数存入的个数 erase() (1) 输入是一个x , 删除全部x , 时间复杂度 O(k + logn) (2) 输入是一个迭代器 , 删除这个迭代器 map / multimap insert() 插入的是一个pair erase() 输入的参数是pair 或者 迭代器 find() 支持[] unordered_set , unordered_map , unordered_multiset , unordered_multimap 基本跟上面一个一样 查找删改时间复杂度是 O(1) 不支持lower_bound()/upper_bound() 迭代器的++ -- bitset 压位 bitset\u003c放大小\u003e s; 初始化时候全为0 —— false; ~取反 \u0026且 |或 ^异或 == , != 移位 \u003c\u003c \u003e\u003e 支持[] count() 返回有多少个1 any() 判断是否有1 none() 判断是否全为0 set() 把所有位置为1 set(k,v) 将第k位变成v reset() 把所有位置为0 flip() 等价于~ flip(x) 第k位取反 基础算法 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:0:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"快速排序 const int N = 1e6 + 10; int n; int q[N]; void quick_sort(int *q,int l,int r) { if (l \u003e= r) return; int x = q[l+r\u003e\u003e1], i = l-1, j = r + 1; while (i \u003cj) { do i++; while (q[i] \u003c x); do j--; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j+1 , r); } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:1:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"归并排序 const int N = 1e6 + 10; int n; int q[N], tmp[N]; void merge_sort(int q[],int l,int r) { if (l \u003e= r) return; int mid = l + r \u003e\u003e 1; merge_sort(q, l, mid), merge_sort(q, mid+1, r); int k = 0, i = l, j = mid +1; while (i \u003c= mid \u0026\u0026 j \u003c= r) if (q[i] \u003c= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while (i \u003c= mid) tmp[k++] = q[i++]; while (j \u003c= r) tmp[k++] = q[j++]; for (i = l, j = 0; i\u003c= r; i++, j++) q[i] = tmp[j]; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:2:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"二分 AcWing 789. 图解 y总的二分模板 （最容易理解版本 ) - AcWing //查找左边界 SearchLeft 简写SL int SL(int l, int r) { while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } //查找右边界 SearchRight 简写SR int SR(int l, int r) { while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; //需要+1 防止死循环 if (check(mid)) l = mid; else r = mid - 1; } return r; } 704 35 34 69 367 STL 数据结构 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:3:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"单链表 #include\u003ciostream\u003e using namespace std; const int N = 100000; int e[N], ne[N]; int head, idx; void init() { head = -1; idx = 0; } void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx++; } void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx++; } void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u003e\u003em; init(); while(m--) { int k, x; char op; cin \u003e\u003e op; if (op == 'H') { cin \u003e\u003e x; add_to_head(x); } else if (op == 'D') { cin \u003e\u003e k; if(!k) head = ne[head]; remove(k-1); } else { cin \u003e\u003e k \u003e\u003e x; add (k-1, x); } // cout \u003c\u003c op \u003c\u003c endl; } for (int i = head; i!= -1; i = ne[i]) cout \u003c\u003c e[i] \u003c\u003c ' '; cout \u003c\u003c endl; return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:4:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"双链表 const int N = 100000; int e[N], ne[N]; int head, idx; void init() { head = -1; idx = 0; } void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx++; } void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx++; } void remove(int k) { ne[k] = ne[ne[k]]; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:5:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"栈 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:6:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"单调栈 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n ; int skt[N], tt; int main () { cin \u003e\u003e n; for (int i = 0; i\u003c n; i++) { int x; cin \u003e\u003e x; while (tt \u0026\u0026 skt[tt] \u003e= x) tt--; if (tt) cout \u003c\u003c skt[tt] \u003c\u003c \" \"; else cout \u003c\u003c -1 \u003c\u003c \" \"; skt[++tt] = x; } return 0; } 单调递增：小于，单调递减：大于 class Solution { public: int sumSubarrayMins(vector\u003cint\u003e\u0026 arr) { int n = arr.size(); vector\u003cint\u003e left(n, -1), right(n, -1); stack\u003cint\u003e skt1; // ++ for (int i = 0; i \u003c n; ++ i) { while (!skt1.empty() \u0026\u0026 arr[skt1.top()] \u003e= arr[i]) { right[skt1.top()] = i; skt1.pop(); } left[i] =skt1.empty()? -1: skt1.top(); skt1.push(i); } for (int i = 0; i \u003c n; ++ i) { cout \u003c\u003c left[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; for (int i = 0; i \u003c n; ++ i) { cout \u003c\u003c right[i] \u003c\u003c \" \"; } return 1; } }; ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:7:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"单调队列 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:8:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"优先队列 #include\u003cbits/stdc++.h\u003e using namespace std; // 自定义比较函数，需重载 () 运算符 struct cmp { bool operator() (pair\u003cint, int\u003e \u0026a, pair\u003cint, int\u003e \u0026b) { return a.first \u003e b.first; // 小根堆 } }; // 自定义数据结构，需重载 \u003c 运算符 struct Info { int h_; Info(int h) : h_(h) {} bool operator\u003c(const Info\u0026 t) const // 不加const会报错！ { return h_ \u003e t.h_; // 小根堆 } }; int main() { // 默认大根堆, 第三个参数 less\u003cint\u003e 可以不加 priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e\u003e q1; // 小根堆 priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q2; // 自定义比较函数 priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, cmp\u003e q3; // 自定义数据类型 priority_queue\u003cInfo, vector\u003cInfo\u003e\u003e q4; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:9:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"KMP https://www.acwing.com/blog/content/2347/ const int N = 100010, M= 1000010; int n, m; char p[N], s[M]; int ne[N]; int main() { cin \u003e\u003e n \u003e\u003e p + 1 \u003e\u003e m \u003e\u003e s + 1; // get next array for (int i = 2, j = 0; i \u003c= n; i++) { while (j \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j+1]) j++; ne[i] = j; } for (int i = 1, j = 0; i \u003c= m; i++) { while (j \u0026\u0026 s[i] != p[j +1]) j = ne[j]; if (s[i] == p[j+1]) j++; if (j == n) { // match success printf(\"%d \", i- n); j = ne[j]; } } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:10:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"Trie const int N = 100010; int son[N][26], cnt[N], idx; // 下标是0的点，即是根节点，又是空节点 void insert(const char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } cnt[p]++; } int query(const char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:11:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"并查集 https://www.acwing.com/problem/content/description/838/ #include \u003ciostream\u003e using namespace std; const int N = 100010; int n,m; int p[N]; // 返回x祖宗节点 + 路径压缩 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) p[i] = i; while (m--) { char op[2]; int a,b; scanf(\"%s%d%d\", op, \u0026a, \u0026b); if (op[0] == 'M') p[find(a)] = find(b); else { if (find(a) == find(b)) puts(\"Yes\"); else puts(\"No\"); } } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:12:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"堆 堆排序 https://www.acwing.com/problem/content/840/ // // Created by zhuzhicheng on 2022/8/28. // 838. 堆排序 // https://www.acwing.com/problem/content/840/ #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 100010; int n, m; int h[N], cnt; void down(int u) { int t = u; if (u * 2 \u003c= cnt \u0026\u0026 h[u * 2] \u003c h[t]) t = u * 2; if (u * 2 + 1 \u003c= cnt \u0026\u0026 h[u * 2 + 1] \u003c h[t]) t = u * 2 + 1; if (u != t) { swap(h[u], h[t]); down(t); } } void up(int u) { while (u / 2 \u0026\u0026 h[u / 2] \u003e h[u]) { swap(h[u / 2], h[u]); u /= 2; } } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; ++i) { scanf(\"%d\", \u0026h[i]); } cnt = n; // for (int i = 1; i \u003c= n / 2; ++i) down(i); for (int i = n / 2; i; i--) down(i); while (m--) { printf(\"%d \", h[1]); h[1] = h[cnt--]; down(1); } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:13:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"线段树 关于线段树 - AcWing 模拟堆c 数学知识 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:14:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"质数 试除法 #include \u003ciostream\u003e using namespace std; bool is_prime(int n) { if (n \u003c 2) return false; for (int i = 2; i \u003c= n / i; i++) { if (n % i == 0) return false; } return true; } int main () { int n; cin \u003e\u003e n; for (int i = 0; i\u003c n; i++) { int x; cin \u003e\u003e x; if(is_prime(x)) puts(\"Yes\"); else puts(\"No\"); } return 0; } 分解质因数 质因数（素因数或质因子）在数论里是指能整除给定正整数的质数。 #include \u003ciostream\u003e using namespace std; void divide(int n) { for (int i = 2; i \u003c= n/i; i++) { if (n % i == 0) { // i 一定是质数 int s = 0; while(n % i == 0) { n /= i; s ++; } printf(\"%d %d\\n\", i, s); } } if (n \u003e 1) printf(\"%d %d\\n\", n, 1); cout \u003c\u003c \"\\n\"; } int main () { int n; cin \u003e\u003e n; for (int i = 0; i\u003c n; i++) { int x; cin \u003e\u003e x; divide(x); } return 0; } 筛质数(埃shi筛法) https://www.acwing.com/solution/content/7950/ #include \u003ciostream\u003e using namespace std; const int N = 1000010; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i =2; i \u003c= n; i++) { if (!st[i]) { primes[cnt ++] = i; for (int j = i; j \u003c= n; j += i) st[j] = true; } } } int main() { int n; cin \u003e\u003e n; get_primes(n); cout \u003c\u003c cnt; return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:15:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"约数 试除法 #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e using namespace std; vector\u003cint\u003e get_divisions(int n) { vector\u003cint\u003e res; for (int i = 1; i \u003c= n / i; i++) if (n % i == 0) { res.push_back(i); if (i != n / i) res.push_back(n / i); } sort(res.begin(), res.end()); return res; } int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { int x; cin \u003e\u003e x; auto res = get_divisions(x); for (auto t : res) cout \u003c\u003c t \u003c\u003c \" \"; cout \u003c\u003c endl; } return 0; } 约数个数 $N=P1^{\\alpha 1}.P2^{\\alpha 2}.P3^{\\alpha 3}…Pk^{\\alpha k}$ 约数个数为 $$(\\alpha 1+1)(\\alpha 2+1)(\\alpha 3+1)…(\\alpha k+1)$$ #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e #include\u003cunordered_map\u003e using namespace std; typedef long long LL; const int mod = 1e9 + 7; int main() { int n; cin \u003e\u003e n; unordered_map\u003cint, int\u003e primes; while (n--) { int x; cin \u003e\u003e x; for (int i = 2; i \u003c= x / i; i++) while (x % i == 0) { x /= i; primes[i] ++; } if (x \u003e 1) primes[x] ++; } LL res = 1; for (auto prime : primes) res = res * (prime.second + 1) % mod; cout \u003c\u003c res; return 0; } 约数之和为$$(P1^0+ P1^1+P1^2+…+P1^{\\alpha 1})…(Pk^0+ Pk^1+Pk^2+…+Pk^{\\alpha k})$$ #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e #include\u003cunordered_map\u003e using namespace std; typedef long long LL; const int mod = 1e9 + 7; int main() { int n; cin \u003e\u003e n; unordered_map\u003cint, int\u003e primes; while (n--) { int x; cin \u003e\u003e x; for (int i = 2; i \u003c= x / i; i++) while (x % i == 0) { x /= i; primes[i] ++; } if (x \u003e 1) primes[x] ++; } LL res = 1; for (auto prime : primes) { int p = prime.first; int a = prime.second; LL t = 1; while (a--) t = (t * p + 1) % mod; res = res * t % mod; } cout \u003c\u003c res; return 0; } 最大公约数（欧几里得算法） #include \u003ciostream\u003e using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { int n; cin \u003e\u003e n; while (n--) { int a, b; cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c gcd(a, b) \u003c\u003c endl; } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:16:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"欧拉函数 1∼N 中与 N 互质（最大公约数为1）的数的个数被称为欧拉函数，记为 ϕ(N)。 https://www.acwing.com/solution/content/8702/ #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; int main() { int n; cin \u003e\u003e n; while (n--) { int a; cin \u003e\u003e a; int res = a; for (int i = 2; i \u003c= a / i; i++ ) { if (a % i == 0) { res = res / i * (i - 1); while (a % i == 0) a /= i; } } if (a \u003e 1) res = res / a * (a - 1); cout \u003c\u003c res \u003c\u003c endl; } return 0; } 筛法求欧拉函数 给定一个正整数n，求1~n中每个数的欧拉函数之和。 https://www.acwing.com/solution/content/3952/ #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; typedef long long LL; const int N = 1000010; int primes[N], cnt; int phi[N]; bool st[N]; LL get_eulers(int n) { phi[1] = 1; for (int i = 2; i \u003c= n; ++ i) { if (!st[i]) { primes[cnt ++] = i; phi[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; ++ j) { st[primes[j] * i] = true; if (i % primes[j] == 0) { phi[primes[j] * i] = primes[j] * phi[i]; break; } phi[primes[j] * i] = (primes[j] - 1) * phi[i]; } } LL res = 0; for (int i = 1; i \u003c= n; ++ i) { res += phi[i]; } return res; } int main() { int n; cin \u003e\u003e n; cout \u003c\u003c get_eulers(n) \u003c\u003c endl; return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:17:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"快速幂 #include\u003ciostream\u003e using namespace std; using LL = long long; LL qmi(LL a, int b, int p) { LL res = 1; while(b) { if (b\u00261) res = res * a % p; b \u003e\u003e= 1; a = a*a %p; } return res; } int main() { int n; cin\u003e\u003en; while(n--) { int a,b,p; long long res=1; cin\u003e\u003ea\u003e\u003eb\u003e\u003ep; cout \u003c\u003c qmi(a,b,p) \u003c\u003cendl;; } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:18:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"欧几里得算法 (辗转相除法) ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:19:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"中国剩余定理 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:20:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"高斯消元 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:21:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"求组合数 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:22:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"容斥原理 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:23:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"博弈论 拆分Nim游戏 #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003ccstring\u003e #include \u003cunordered_set\u003e using namespace std; const int N = 110; int f[N]; int sg(int x) { if (f[x] != -1) return f[x]; unordered_set\u003cint\u003e S; for (int i = 0; i \u003c x; i++) for (int j = 0; j \u003c= i; j++) { S.insert(sg(i) ^ sg(j)); } // mex op for (int i = 0;; i++) if (!S.count(i)) return f[x] = i; } int main() { int n ; cin \u003e\u003e n; memset(f, -1, sizeof f); int res = 0; for (int i = 0; i \u003c n; i++) { int x; cin \u003e\u003e x; res ^= sg(x); } if (res) puts(\"Yes\"); else puts(\"No\"); return 0; } 搜索与图论 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:24:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"图的定义问题 微信公众平台 邻接矩阵 这是一种使用二维矩阵来进行存图的方式。 适用于边数较多的**「稠密图」使用，当边数量接近点的数量的平方，即 时，可定义为「稠密图」**。 // 邻接矩阵数组：w[a][b] = c 代表从 a 到 b 有权重为 c 的边 int[][] w = new int[N][N]; // 加边操作 void add(int a, int b, int c) { w[a][b] = c; } 邻接表 这也是一种在图论中十分常见的存图方式，与数组存储单链表的实现一致（头插法）。 这种存图方式又叫**「链式前向星存图」**。 适用于边数较少的**「稀疏图」使用，当边数量接近点的数量，即 时，可定义为「稀疏图」**。 int N = 110, M = 6010; int[] he = new int[N], e = new int[M], ne = new int[M], w = new int[M]; int idx; void add(int a, int b, int c) { e[idx] = b; ne[idx] = he[a]; he[a] = idx; w[idx] = c; idx++; } 首先 idx 是用来对边进行编号的，然后对存图用到的几个数组作简单解释： he 数组：存储是某个节点所对应的边的集合（链表）的头结点； e 数组：由于访问某一条边指向的节点； ne 数组：由于是以链表的形式进行存边，该数组就是用于找到下一条边； w 数组：用于记录某条边的权重为多少。 因此当我们想要遍历所有由 a 点发出的边时，可以使用如下方式： for (int i = he[a]; i != -1; i = ne[i]) { int b = e[i], c = w[i]; // 存在由 a 指向 b 的边，权重为 c } 类 这是一种最简单，但是相比上述两种存图方式，使用得较少的存图方式。 只有当我们需要确保某个操作复杂度严格为O(m) 时，才会考虑使用。 具体的，我们建立一个类来记录有向边信息： class Edge { // 代表从 a 到 b 有一条权重为 c 的边 int a, b, c; Edge(int _a, int _b, int _c) { a = _a; b = _b; c = _c; } } 通常我们会使用 List 存起所有的边对象，并在需要遍历所有边的时候，进行遍历： List\u003cEdge\u003e es = new ArrayList\u003c\u003e(); ... for (Edge e : es) { ... } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:25:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"dfs https://www.acwing.com/problem/content/844/ const int N = 10; int path[N]; int sts[N]; int n; void dfs(int u) { if (u == n) { for (int i = 0 ;i \u003c n; i++) cout \u003c\u003c path[i] \u003c\u003c \" \"; puts(\" \"); return; } for (int i = 0 ;i \u003c n; i++) { if (sts[i] != 1) { path[u] = i + 1; sts[i] = 1; dfs(u+1); sts[i] = 0; } } } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:26:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"八皇后 https://www.acwing.com/problem/content/845/ solve: https://www.acwing.com/solution/content/2820/ #include \u003ciostream\u003e using namespace std; const int N = 10; int n; bool col[N], dg[N], udg[N]; char g[N][N]; void dfs(int u) { if (u == n) { for (int i = 0; i \u003c n; i++) puts(g[i]); puts(\" \"); return; } for (int i = 0; i \u003c n; i++) { if(!col[i] \u0026\u0026 !dg[u + i] \u0026\u0026 !udg[n-u+i]) { g[u][i] = 'Q'; col[i] = dg[u+i] = udg[n-u+i] = true; dfs(u+1); col[i] = dg[u+i] = udg[n-u+i] = false; g[u][i] = '.'; } } } int main() { cin \u003e\u003e n; for (int i = 0; i\u003c n; i++) { for (int j = 0; j\u003c n; j++) { g[i][j] = '.'; } } dfs(0); return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:26:1","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"bfs https://www.acwing.com/problem/content/description/846/ https://www.acwing.com/solution/content/2078/ #include \u003ciostream\u003e #include \u003cqueue\u003e using namespace std; const int N = 102; int g[N][N], d[N][N]; int n, m; using PII = pair\u003cint,int\u003e; int bfs() { queue\u003cPII\u003e q; for(auto \u0026v: d) for (auto \u0026x :v) { x = -1; } d[0][0] = 0; q.push({0,0}); int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1}; while(!q.empty()) { auto t = q.front(); q.pop(); for (int i = 0 ; i \u003c 4; i++) { int x = t.first + dx[i], y = t.second + dy[i]; if (x \u003e= 0 \u0026\u0026 x \u003c n \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c m \u0026\u0026 g[x][y] == 0 \u0026\u0026 d[x][y] == -1) { d[x][y] = d[t.first][t.second] + 1; q.push({x,y}); } } } return d[n-1][m-1]; } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c m; j++) { cin \u003e\u003e g[i][j]; } } cout \u003c\u003c bfs() \u003c\u003c endl; return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:27:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"树的bfs https://www.acwing.com/solution/content/13513/ （数组建立邻接表） 树的dfs //邻接表 int h[N], e[N * 2], ne[N * 2], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } 树的bfs模板 // 需要标记数组st[N], 遍历节点的每个相邻的便 void dfs(int u) { st[u] = true; // 标记一下，记录为已经被搜索过了，下面进行搜索过程 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { dfs(j); } } } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:28:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"树的dfs 差分与前缀和 前缀和与差分 图文并茂 超详细整理（全网最通俗易懂）_前缀和差分_林小鹿@的博客-CSDN博客 动态规划 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:29:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"背包问题 LFU \u0026\u0026 LRU ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:30:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"LFU ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:31:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"Nvidia（英伟达）于2020年收购Mellanox公司（专注于提供IB网络、Ethernet网络产品，如ConnectX系列网卡），并在同年推出BlueField DPU，自此，DPU成为芯片领域一个新的聚焦点，Marvell、Pensando、Broadcom（博通）、Intel等国外传统半导体/芯片公司纷纷入局，国内的中科驭数、星云智联等芯片公司和一大批初创公司也提出了自己的DPU方案。 Nvidia CEO 黄仁勋在 GTC（GPU技术大会）上提出：“用于通用计算的 CPU，用于加速计算的 GPU，用于网络数据处理的 DPU，将成为未来计算的三大支柱”[1]。究竟什么是 DPU？为什么它将有可能与传统的 CPU、GPU平起平坐呢？ ","date":"2021-12-29","objectID":"/posts/dpu/:0:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"一、DPU是什么 数据处理单元（Data Processing Unit），通常称为DPU，是一种新型的可重新编程的结合高性能网络接口的高性能处理器。这些网络接口经过优化，可以执行和加速由数据中心服务器执行的网络和存储功能[2]。DPU就像GPU一样插入服务器的PCIe插槽，它们允许服务器将网络和存储功能从CPU卸载到DPU，让CPU只专注于运行操作系统和系统应用程序。DPU通常使用可重新编程的FPGA结合网络接口卡来加速网络流量，就像使用GPU通过将数学运算从CPU卸载到GPU来加速人工智能(AI)应用程序一样。 ","date":"2021-12-29","objectID":"/posts/dpu/:1:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"二、DPU的产生与发展 网络的发展推动着DPU的出现，DPU的发展史也是网卡的发展史。 ","date":"2021-12-29","objectID":"/posts/dpu/:2:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"第⼀阶段：基础功能网卡 基础功能网卡即传统网卡只提供了最基础的网络接口，通过PCIE等总线，作为主机和外部网络连接的桥梁。基础网卡一般提供2x10G或2x25G带宽吞吐能力，网络的TCP/IP协议栈的处理由主机的操作系统实现，其硬件卸载能力较弱，主要是Checksum，LRO/LSO等，支持SR-IOV（Single Root I/O Virtualization），以及有限的多队列能力。 ","date":"2021-12-29","objectID":"/posts/dpu/:2:1","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"第⼆阶段：智能网卡 借助软硬件融合的思想，将操作系统的部分网络协议栈（TCP/IP、VLAN、GENEVE）由硬件来实现，实现对于各种网络基础功能的支持和加速，从而释放CPU的通用算力，由此诞生了各种offload NIC（支持卸载的网卡）。随着网络协议的复杂化和多样化，固定协议的offload无法与网络协议的快速更新发展相匹配，经历1-2年研发周期的固化网卡面临着被迅速淘汰的危机，在这样的背景下就要求网卡具有一定的可编程能力，从而满足协议更新的需求，延长网卡的市场周期。我们把拥有可编程能力的硬件卸载网卡叫做SmartNIC（智能网卡），它具有更加丰富的硬件卸载能力和一定的可编程性支持，如：OVS Fastpath硬件卸载，基于RoCE和RoCEv2的RDMA网络硬件卸载，融合网络中无损网络能力（PFC，ECN，ETS等）的硬件卸载，存储领域NVMe-oF（NVMe-over-Fabrics）的硬件卸载，以及安全传输的数据面卸载等。此时期的智能网卡以数据平面的卸载为主。 ","date":"2021-12-29","objectID":"/posts/dpu/:2:2","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"第三阶段：DPU智能⽹卡 DPU可以看作是第二代智能网卡，它在第一代智能网卡的基础上加入了片上CPU Core（ARM/MIPS），可以卸载控制平面的任务和一些灵活复杂的数据平面任务，有更强的可编程性。DPU主要分为网络单元和计算单元，网络单元负责与片上CPU、外设、主机的连接，计算单元赋予了DPU通用计算能力，与各种硬件加速器协同实现各种计算任务的加速，如DPI（深度包解析）、RegEx（正则匹配）、IPSec/AES（加密）等。DPU的出现使得网卡的卸载不再局限于网络功能，在网络、计算、存储、安全各个方面都有了更加丰富的支持。目前DPU智能网卡支持PCIe Root Complex模式和Endpoint模式，在配置为PCIe Root Complex模式时，可以实现NVMe存储控制器，与NVMe SSD磁盘一起构建存储服务器。 ","date":"2021-12-29","objectID":"/posts/dpu/:2:3","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"三、DPU的优势 DPU的功能主要包括了网络、计算、存储、安全多个方面。 基于网卡发展而来的DPU，其最核心的功能集中在网络方面，可以用于卸载网络虚拟化（OVS等）、SR-IOV、防火墙或任何其他需要高速数据包处理的应用程序。目前，主流的DPU支持高达200Gb/s的以太网和InfiniBand网络处理，释放CPU算力，从而解决主机上计算密集型应用的性能瓶颈。 对于存储，DPU可以作为标准的NVMe设备呈现给主机系统，同时它可以采用NVMe-oF解决方案，使用来自数据中心其他服务器的远程NVMe存储器。DPU也可以直接通过PCIe连接NVMe SSD，然后通过网络暴露给数据中心的其他DPU，所有这些活动都不需要传统的主机服务器的参与。DPU可以卸载NVMe-oF存储直连、加密、弹性存储、数据完整性、压缩和去重等，这使得远程存储的延迟与性能和直连存储相接近，提供了构建数据中心的高性能池化存储的新方式。 对于计算，DPU可用于运行与服务器上的主管理程序不同的管理程序，从而使x86 CPU或GPU甚至FPGA成为另一种跨越整个数据中心多台服务器的集中资源。或者只是将这些资源直接连接到DPU，由DPU将它们暴露到网络上。这样以来，数据中心内的任何主机都可以访问各种处理引擎的资源，任何主机上的任何应用程序都可以自由地利用这些加速器，无论它们实际物理位置在哪里。 在数据中心 “以数据为中心” 的趋势下，DPU为云服务提供商提供了资源池化的新方式，使其能够在基础架构内的任何位置组合存储、网络和计算资源，实现按需分配，进一步提高资源的利用率，为数据中心降低成本，达到更高的经济效益。此外，通过将安全任务卸载到DPU上，云服务提供商能够在为云租户提供裸机即服务（bare-metal-as-a-service）的同时保证服务环境的正确性与安全性。AWS/阿里云纷纷自研，英特尔/英伟达竞相布局，DPU已经在各大数据中心展现出巨大的价值。 ","date":"2021-12-29","objectID":"/posts/dpu/:3:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"四、DPU的核心要素 DPU SoC的核心并不是一个高性能的嵌入式CPU，由于能耗限制，期待DPU的嵌入式CPU达到比主机CPU更强的数据处理能力是不现实的。对于传统的x86CPU来说，100Gb/s的数据包处理速度已经会带来巨大的处理负担，极端情况下甚至会导致数据包的堆积和丢失。在400Gb/s的高速网络下，期待DPU的低功耗嵌入式CPU去处理每个数据包并不是一个合理的解决方案。Nvidia的Bluefield DPU和Pensando的Elba DPU解决方案都表明，在数据包处理负担过重的情况下，由嵌入式CPU负责控制路径的初始化和异常情况的处理可能是更好的DPU实现方式。 DPU在架构上主要包含两个部分。首先是继承于智能网卡的网络处理单元，例如Nvidia Bluefield DPU集成了ConnectX-6网卡单元，Pensando的Elba DPU集成了P4的数据包处理流水线。网络处理单元具有高性能的网络接口，用来连接外部高速网络，目前的主流DPU产品支持100Gb/s~200Gb/s的网络接口，未来两到三年会逐步提升至400Gb/s甚至800Gb/s的水平。第二个部分是SoC，主要包含低功耗的嵌入式CPU和各种HAC（Hardware Accelerator）。嵌入式CPU通常会使用ARM核或者其他的低功耗处理器（Fungible使用了MIPS 64处理器）以控制DPU的整体功耗。有了嵌入式CPU的支撑，DPU都会运行完整一个完整的操作系统（通常是完整的Linux），带来了很强的可编程性，并配合各种灵活可编程的加速引擎用来提供更强的卸载和加速能力。 为了灵活使用DPU上的各种加速器，厂商通常会提供相应的SDK（通常会与开源生态相兼容），Nvidia DPU就提供了DOCA（Data-Center-Infrastructure-On-A-Chip Architecture）SDK来实现更加灵活便捷的硬件控制方式和编程手段，并集成P4、DPDK等，以利用开源生态。简单来说，DOCA于DPU就像CUDA于GPU，这也是Nvidia将DPU和CPU、GPU列为未来的三大计算支撑的一个着力点。 ","date":"2021-12-29","objectID":"/posts/dpu/:4:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"五、DPU解决方案 我们选择了几种主流的DPU产品对其配置和架构做简单的介绍： ","date":"2021-12-29","objectID":"/posts/dpu/:5:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"1、Nvidia Bluefield-2 Nvidia于2020年收购Mellanox，同年推出基于ConnectX网卡的BlueField DPU产品，并于2021年推出了Bluefield-2 DPU产品。BlueField-2 DPU在ConnectX-6的基础上增加了SoC部分，由嵌入式CPU处理控制平面，CX6的eSwitch处理数据平面，从而构建完整的DPU处理单元。 BlueField-2的主要规格如下： CPU：8x ARM A72核 内存控制器：8Gb 或 16Gb DDR4-3200内存 高速网络连接：2x100Gbps或1x 200Gbps以太网或InfiniBand，基于Mellanox ConnectX-6 Dx 高速数据包处理加速：类似于其他ConnectX-6 Dx解决方案的多个卸载引擎和eSwitch流逻辑 加速器：用于正则表达式、重复数据删除和压缩算法以及加密卸载 PCIe Gen4通道：16通道PCIe Gen3/4 PCIe switch 安全和管理功能：Hardware RoT（Root of Trust），具有用于带外（out-of-band）管理的1GbE接口 运行的操作系统：许多Linux发行版，如Ubuntu、CentOS、Yocoto以及VMware ESXi ","date":"2021-12-29","objectID":"/posts/dpu/:5:1","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"2、Fungible F1 Fungible是首批为其提供的这种新型处理器命名为DPU的公司之一。 Fungible F1主要规格如下： CPU：8个4x SMT MIPS-64核心的数据集群 内存控制器：2x DDR4控制器加上对8GB HBM2（High Bandwidth Memory）的支持 高速网络连接：2x 400Gbps网络接口，能够聚合高达800Gbps或8x 100GbE 高速数据包处理加速：用于解析、封装、解封装、查找和传输/接收加速的类P4语言 加速器：多个加速器，包括用于数据移动的加速器 PCIe Gen4通道：四个x16主机单元，可以作为根或端点运行 安全和管理功能：4核x2路SMT控制集群，具有安全区域、安全启动和Hardware RoT（Root of Trust），还有加密引擎和随机数生成等功能 运行的操作系统：Linux ","date":"2021-12-29","objectID":"/posts/dpu/:5:2","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"3、Pensando Elba Pensando是一家云创业公司，由一群著名的前思科工程师创立。Elba DPU由嵌入式CPU处理控制平面，P4流水线处理数据平面。 pensando Elba主要规格如下： CPU：16个ARM A72核 内存控制器：双通道DDR4/DDR5内存支持8–64GB。Pensando在之前的型号中使用HBM，但后来转而使用更便宜、更灵活的DDR 高速网络连接：2x 200Gbps网络接口 高速包处理加速：P4可编程路径 加速器：用于加密、压缩和数据移动等 PCIe Gen4通道：32x PCIe Gen4通道和8个端口 安全和管理功能：Hardware RoT（Root of Trust），具有用于带外管理的1GbE接口 运行的操作系统：支持DPDK的Linux，以及VMware ESXi ","date":"2021-12-29","objectID":"/posts/dpu/:5:3","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"下一代DPU解决方案 Nvidia推出BlueField-2 DPU时，提出了未来三年DPU的路标。总体上来看，其核心是以400Gb/s的链路速度为代表的高速网络处理能力，以及更强的片上CPU处理能力。 目前，Nvidia已经发布了新一代DPU BlueField-3。它支持400Gbps网络，采用32通道PCIe Gen 5.0，搭载16核Armv8.2+ A78 CPU，具有16GB板载DDR5[7]，较上一代DPU性能实现了极大的提升。 ","date":"2021-12-29","objectID":"/posts/dpu/:5:4","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"六、工业界应用 ","date":"2021-12-29","objectID":"/posts/dpu/:6:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"亚马逊AWS Nitro系统 AWS的Nitro是DPU在云基础设施中应用的首批示例之一。Amazo Web Services分解了传统服务器，添加Nitro IO加速卡(ASIC)以通过整体Nitro卡控制器处理VPC（虚拟私有云）、EBS、实例存储、安全性等。Nitro将虚拟机管理程序、网络虚拟化和存储虚拟化任务分流到专用硬件，以释放主CPU。 AWS Elastic Compute Cloud实例基于PCIe连接的Nitro卡以及X86或Arm处理器和DRAM。有各种EC2实例类型—通用型或针对计算、内存、存储、机器学习和横向扩展用例进行了优化[8]。 ","date":"2021-12-29","objectID":"/posts/dpu/:6:1","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"七、总结 随着5G、大数据和云计算等新技术的蓬勃发展，数据中心的规模增大，基础架构需要的网络带宽不断提升。同时服务器物理核密度不断提高，支撑CPU的网络从25Gb/s增加到200Gb/s，服务器本身对网络基础功能的处理要求不断提高，在CPU内核上产生了过多的计算开销，这是DPU智能网卡产生的最关键原因之一。 DPU旨在卸载和基础网络处理相关的计算任务，利用各种硬件加速器，以比主机CPU更低的成本实现对各种网络功能和虚拟化的支持，进一步支持计算、存储、安全等方面的加速卸载，从而释放主机CPU的通用算力。 进一步，云服务提供商借助DPU实现各种计算、存储、网络资源的池化和按需分配，能够进一步提高资源的利用率，为数据中心降低成本，实现更高的经济效益。 ","date":"2021-12-29","objectID":"/posts/dpu/:7:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"Reference [1] Cadalyst Staff.What Is a DPU? The Third Pillar of Computing, Says NVIDIA [EB/OL]. (2020-5-20). https://www.cadalyst.com/design-related-technologies/graphics-cards-and-cpus/what-dpu-third-pillar-computing-says-nvidia-7585 [2] Premio Inc. What Is A DPU (Data Processing Unit)? [EB/OL]. (2021-5-12). https://premioinc.com/blogs/blog/what-is-a-dpu-data-processing-unit [3] 中国科学院计算技术研究所，鄢贵海等.专用数据处理器（DPU）技术白皮书[EB/OL]. (2021-10). http://www.yusur.tech/zkls/pdf/DPU-whitepaper-v1.0-final-21.pdf [4] KEVIN DEIERLING.What Is a DPU? [EB/OL].(2020-5-20). https://blogs.nvidia.com/blog/2020/05/20/whats-a-dpu-data-processing-unit/ [5] Patrick Kennedy What is a DPU A Data Processing Unit Quick Primer. [EB/OL]. (2020-9-29). https://www.servethehome.com/what-is-a-dpu-a-data-processing-unit-quick-primer/ [6] Patrick Kennedy. NVIDIA Shows DPU Roadmap Combining Arm Cores GPU and Networking [EB/OL]. (2020-10-5). https://www.servethehome.com/nvidia-shows-dpu-roadmap-combining-arm-cores-gpu-and-networking/ [7] NVIDIA Corporation.NVIDIA BLUEFIELD-3 DPU datasheet [EB/OL]. https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/documents/datasheet-nvidia-bluefield-3-dpu.pdf [8] AWS Events. Deep dive into the Nitro system[EB/OL]. (2019-12-10). https://www.youtube.com/watch?v=rUY-00yFlE4 [9] DPU家族大探秘：https://mp.weixin.qq.com/s/jmQG5uLjOlyIe-5QFL0PiQ ","date":"2021-12-29","objectID":"/posts/dpu/:8:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"第 1 步，启用 WSL 以管理员身份打开 PowerShell 工具并运行以下命令 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:1","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"第 2 步，启用“虚拟机平台” WSL 2 需要启用 Windows 10 的 “虚拟机平台” 特性。它独立于 Hyper-V，并提供了一些在 Linux 的 Windows 子系统新版本中可用的更有趣的平台集成。 要在 Windows 10（2004）上启用虚拟机平台，以管理员身份打开 PowerShell 并运行： dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 要在 Windows 10（1903，1909）上启用虚拟机平台，请以管理员身份打开 PowerShell 并运行： Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform -NoRestart 重启系统 ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:2","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"第 3 步，更新内核组件 wsl_update_x64.exe ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:3","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"第 4步，设置 WSL 2 为默认值 以管理员身份打开 PowerShell，然后运行以下命令以将 WSL 2 设置为 WSL 的默认版本： wsl --set-default-version 2 ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:4","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"第 5 步，安装 Linux 发行版 从 Microsoft Store 中选择并安装 Linux 发行版 有几种不同的发行版可供选择，包括 OpenSUSE、Pengwin、Fedora Remix 和 Alpine Linux。 个人推荐Ubuntu 20.04 LTS（尽管也有 18.04 LTS 和 16.04 LTS 可用）。 要在 Windows 10 上安装 Ubuntu，请打开 Microsoft Store 应用，搜索 “Ubuntu 20.04”。 wsl.exe --set-version Ubuntu 2 ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:5","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"不稳定排序算法 [堆排序]、[快速排序]、[希尔排序]、[直接选择排序] 稳定排序算法 [基数排序]、[冒泡排序]、[直接插入排序]、[折半插入排序]、[归并排序] ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:0","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"1.冒泡排序 void bubble_sort(vector\u003cint\u003e \u0026arry){ for(int i = 0 ;i\u003c array.size()-1 ; i++){ int index = 0 ; for(int j = 0; j \u003c array.size()- 1 - i ;j ++){ if(array[j] \u003e array[j+1]) swap(array[j],array[j+1]); } } } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:1","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"2.选择排序 void select_sort(vector\u003cint\u003e \u0026arry){ for(int i = 0 ;i\u003c array.size();i++){ int index = i ; for(int j = i+ 1; j\u003c array.size(); j++) if(array[j]\u003carray[index]) index = j; } swap(array[index],array[i]); } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:2","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"3.插入排序(简单插入排序) void insert_sort(vector\u003cint\u003e \u0026arry){ for(int i = 1;i\u003c array.size();i++){ int index = i-1; int cur = array[i]; while(index \u003e=0 \u0026\u0026 array[i]\u003carray[index]) { array[index+1]=array[index]; index -- ; } array[index+1] = cur; } } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:3","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"4.希尔排序 void shell_sort(vector\u003cint\u003e \u0026array){ int n = array.size(); for(int gap = n/2 ; gap \u003e 0; gap /=2){ for(int i = gap;i\u003c n ;i++){ insert(array,gap,i); } } } void insert(vector\u003cint\u003e \u0026array, int gap, int i){ int inserted = array[i]; int j; for(int j = i-gap; j\u003e=0 \u0026\u0026 inserted \u003c array[j]; j-= gap) array[j+gap] = array[j]; array[j+gap] = inserted; } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:4","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"5.快速排序 void quick_sort(vector\u003cint\u003e \u0026arry, int left ,int right){ if(left \u003c right){ int p = partition(array,left,right); quick_sort(array,left,p-1); quick_sort(array,p+1,right); } } int partition(vector\u003cint\u003e \u0026arry, int left ,int right){ int p = left; int index = p+1; for(int i = index ; i\u003c=right;i++){ if(array[i]\u003carray[index]){ swap(array[i],array[index]); index++; } } swap(array[p],array[index-1]); return index-1; } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:5","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"6.归并排序 void merge_sort(vector\u003cint\u003e \u0026array,int left,int right){ if(left\u003cright){ int mid = left + (right - left) \u003e\u003e 1; merge_sort(array,left,mid); merge_sort(array,mid+1,right); merge(array,left,mid,right); } } void merge(vector\u003cint\u003e \u0026array,int left,int mid ,int right){ int * tmp = new int[right - left + 1]; int i = left; int j = mid+1; int index = 0; while(i\u003c=mid \u0026\u0026 j\u003c= right) tmp[index++] = array[i]\u003carray[j]?array[i++]:array[j++]; while(i\u003c=mide) tmp[index++] = array[i++]; while(j\u003c=right) tmp[index++] = array[j++]; for(int i = 0 ;i\u003c right - left +1 ; i++) array[left + i] = tmp[i]; delete tmp; } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:6","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"7.堆排序 void heap_sort(vector\u003cint\u003e \u0026array,int size){ //构建大根堆 for(int i = size/2 -1 ; i\u003e=0 ;i--) adjust_heap(array,size,i); //调整大根堆 for(int i = size - 1;i\u003e = 1; i--){ swap(array[0],array[i]);// 将当前最大的放置到数组末尾 adjust(array,i,0); //将未完成排序的部分继续进行堆排序 } } void adjust_heap(vector\u003cint\u003e \u0026array, int len, int index){ //len是array的长度，index是第一个非叶子节点的下标 if(index \u003e len) return; int leftc = 2*index + 1; int rightc = 2*index + 2; int maxindex = index; if(leftc \u003c len \u0026\u0026 array[leftc] \u003e array[maxindex]) maxindex = leftc; if(rightc \u003c len \u0026\u0026 array[right] \u003e array[maxinnex]) maxindex = rightc; if(maxindex != index){ swap(array[idnex],array[maxindex]); adjust_heap(array,len,maxindex); } } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:7","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"8.计数排序 ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:8","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"9.基数排序 ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:9","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"10.桶排序","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:10","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"前序遍历 void preorder(Node * head){ if(head!=null) { cout \u003c\u003c head -\u003e val; preorder(head-\u003eleft); preorder(head-\u003eright); } } void preorder(Node * head){ if(!head) return ; stack\u003cNode *\u003e s; s.push(head); while(!s.empty()){ Node * tmp = s.top(); s.pop(); cout \u003c\u003c tmp.val; if(tmp-\u003eleft) s.push(tmp-\u003eleft); if(tmp-\u003eright) s.push(tmp-\u003eright); } } 中序遍历 void inorder(Node * head){ if(head!=null) { inorder(head-\u003eleft); cout \u003c\u003c head -\u003e val; inorder(head-\u003eright); } } void inorder(Node * head){//一直将他的左子树压栈。 一直到左子树最左的节点 if(!head) return ; stack\u003cNode*\u003e s; s.push(head); while(!s.empty() || head!=nullptr){ if(head-\u003eleft!=nullptr) s.push(head-\u003eleft); else{ head = s.top(); s.pop(); cout \u003c\u003c head-\u003eval; if(head-\u003eright!=nullptr) s.push(head.right); } } } 后序遍历 void laterorder(Node * head){ if(head!=null) { laterorder(head-\u003eleft); laterorder(head-\u003eright); cout \u003c\u003c head -\u003e val; } } void laterorder(Node * head){//维护两个栈，第一个栈遍历顺序 中右左; 第二个 左右中。 if(!head) return ; stack\u003cNode * \u003e s1,s2; s1.push(head); while(!s1.empty()){ head = s1.top(); s1.pop(); s2.push(head); if(head-\u003eleft) s1.push(head-\u003eleft); if(head-\u003eright) s1.push(head-\u003eright); } while(!s2.empty()){ head = s2.top(); s2.pop(); cout \u003c\u003c head-\u003eval; } } ","date":"2020-03-29","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["algorithm","tree"],"title":"二叉树遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]