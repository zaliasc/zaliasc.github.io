[{"categories":null,"content":"不稳定排序算法 [堆排序]、[快速排序]、[希尔排序]、[直接选择排序] 稳定排序算法 [基数排序]、[冒泡排序]、[直接插入排序]、[折半插入排序]、[归并排序] ","date":"2023-06-20","objectID":"/posts/sort/:0:0","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"1.冒泡排序 void bubble_sort(vector\u003cint\u003e \u0026arry){ for(int i = 0 ;i\u003c array.size()-1 ; i++){ int index = 0 ; for(int j = 0; j \u003c array.size()- 1 - i ;j ++){ if(array[j] \u003e array[j+1]) swap(array[j],array[j+1]); } } } ","date":"2023-06-20","objectID":"/posts/sort/:0:1","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"2.选择排序 void select_sort(vector\u003cint\u003e \u0026arry){ for(int i = 0 ;i\u003c array.size();i++){ int index = i ; for(int j = i+ 1; j\u003c array.size(); j++) if(array[j]\u003carray[index]) index = j; } swap(array[index],array[i]); } ","date":"2023-06-20","objectID":"/posts/sort/:0:2","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"3.插入排序(简单插入排序) void insert_sort(vector\u003cint\u003e \u0026arry){ for(int i = 1;i\u003c array.size();i++){ int index = i-1; int cur = array[i]; while(index \u003e=0 \u0026\u0026 array[i]\u003carray[index]) { array[index+1]=array[index]; index -- ; } array[index+1] = cur; } } ","date":"2023-06-20","objectID":"/posts/sort/:0:3","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"4.希尔排序 void shell_sort(vector\u003cint\u003e \u0026array){ int n = array.size(); for(int gap = n/2 ; gap \u003e 0; gap /=2){ for(int i = gap;i\u003c n ;i++){ insert(array,gap,i); } } } void insert(vector\u003cint\u003e \u0026array, int gap, int i){ int inserted = array[i]; int j; for(int j = i-gap; j\u003e=0 \u0026\u0026 inserted \u003c array[j]; j-= gap) array[j+gap] = array[j]; array[j+gap] = inserted; } ","date":"2023-06-20","objectID":"/posts/sort/:0:4","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"5.快速排序 void quick_sort(vector\u003cint\u003e \u0026arry, int left ,int right){ if(left \u003c right){ int p = partition(array,left,right); quick_sort(array,left,p-1); quick_sort(array,p+1,right); } } int partition(vector\u003cint\u003e \u0026arry, int left ,int right){ int p = left; int index = p+1; for(int i = index ; i\u003c=right;i++){ if(array[i]\u003carray[index]){ swap(array[i],array[index]); index++; } } swap(array[p],array[index-1]); return index-1; } ","date":"2023-06-20","objectID":"/posts/sort/:0:5","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"6.归并排序 void merge_sort(vector\u003cint\u003e \u0026array,int left,int right){ if(left\u003cright){ int mid = left + (right - left) \u003e\u003e 1; merge_sort(array,left,mid); merge_sort(array,mid+1,right); merge(array,left,mid,right); } } void merge(vector\u003cint\u003e \u0026array,int left,int mid ,int right){ int * tmp = new int[right - left + 1]; int i = left; int j = mid+1; int index = 0; while(i\u003c=mid \u0026\u0026 j\u003c= right) tmp[index++] = array[i]\u003carray[j]?array[i++]:array[j++]; while(i\u003c=mide) tmp[index++] = array[i++]; while(j\u003c=right) tmp[index++] = array[j++]; for(int i = 0 ;i\u003c right - left +1 ; i++) array[left + i] = tmp[i]; delete tmp; } ","date":"2023-06-20","objectID":"/posts/sort/:0:6","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"7.堆排序 void heap_sort(vector\u003cint\u003e \u0026array,int size){ //构建大根堆 for(int i = size/2 -1 ; i\u003e=0 ;i--) adjust_heap(array,size,i); //调整大根堆 for(int i = size - 1;i\u003e = 1; i--){ swap(array[0],array[i]);// 将当前最大的放置到数组末尾 adjust(array,i,0); //将未完成排序的部分继续进行堆排序 } } void adjust_heap(vector\u003cint\u003e \u0026array, int len, int index){ //len是array的长度，index是第一个非叶子节点的下标 if(index \u003e len) return; int leftc = 2*index + 1; int rightc = 2*index + 2; int maxindex = index; if(leftc \u003c len \u0026\u0026 array[leftc] \u003e array[maxindex]) maxindex = leftc; if(rightc \u003c len \u0026\u0026 array[right] \u003e array[maxinnex]) maxindex = rightc; if(maxindex != index){ swap(array[idnex],array[maxindex]); adjust_heap(array,len,maxindex); } } ","date":"2023-06-20","objectID":"/posts/sort/:0:7","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"8.计数排序 ","date":"2023-06-20","objectID":"/posts/sort/:0:8","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"9.基数排序 ","date":"2023-06-20","objectID":"/posts/sort/:0:9","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"},{"categories":null,"content":"10.桶排序","date":"2023-06-20","objectID":"/posts/sort/:0:10","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/sort/"}]