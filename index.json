[{"categories":null,"content":"第二章 内存寻址 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:1:0","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"地址分类 逻辑地址：段+偏移量组成。 线性地址，即虚拟地址，一个32位无符号整数，表示高达4GB的地址空间。 物理地址，用于内存芯片级内存单元寻址。 逻辑地址 --分段--\u003e 线性地址 --\u003eMMU--\u003e物理地址 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:1:1","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"分段机制 此部分可以参考 https://zhuanlan.zhihu.com/p/324210723 进行学习 一个逻辑地址由段选择符（16位）和段内偏移（32位）组成。段选择符存储在段寄存器中。80x86提供了6个段寄存器： cs：代码段寄存器，指向包含程序指令的段。 ss：栈段寄存器，指向包含当前程序栈的段。 ds：数据段寄存器，指向包含静态数据或者全局数据段。 es fs gs：一般用途，可以指向任意段。 每个段通过一个8B大小的段描述符来描述特征。段描述符存储在全局描述符表（GDT）或局部描述符表（LDT）中。GDT通常只有一个；如果进程创建了GDT中没有的段，就拥有自己的LDT。GDT的地址和大小存放在gdtr控制寄存器，LDT的地址和大小存放在ldtr控制寄存器。 为每个段寄存器提供了一个非编程寄存器，当段寄存器内容发送变化时，将从LDT或GDT中加载对应的段描述符到对应的非编程寄存器。 段寄存器存储了段描述符在描述符表中的索引。 线性地址 = [ 段描述符 ]+段内偏移量 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:1:2","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Linux中的分段 Linux下的逻辑地址与线性地址是一致的 用户态的所有进程，都通过用户代码段(__USER_CS)和用户数据段(__USER_DS)来寻址代码和数据。内核态的所有进程，都通过内核代码段(__KERNEL_CS)和内核数据段(__KERNEL_DS)来寻址代码和数据。 四个段都是从0x0开始，即Linux下，逻辑地址和线性地址是一致的。 CPU 的特权等级发生变化时（用户态 \u003c–\u003e 内核态），相应的段寄存器也要更新，（DPL字段代表访问这个段的最低优先级）。 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:1:3","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"硬件分页机制 https://zhuanlan.zhihu.com/p/480796773 线性地址-\u003e物理地址 一个关键任务：比较请求访问的类型与线性地址访问权限，若访问无效，产生缺页异常 一级页表 多级页表 第一级表称为页目录，存放在一页 4K 大小的页面中，具有 2^10 个 4 字节长度的表项。 这些表象指向对应的二级表。 线性地址的最高 10 位（31-22）用作以及表中的索引。 第二级称为页表，长度也是 4K 大小的一个页面，最多有 1K 个 4 字节的表项。 每个 4 字节的表项含有相关页面的 20 位物理基地址。 二级页表使用线性地址的中间 10 位（21-12）作为表项索引值，以获取含有页面 20 物理地址基地址的表项。 该20位页面物理基地址和线性地址中的第12位（页内偏移）组合在一起就得到了分页转换过程的输出值，即对应的的最终物理地址。 对于给定的线性地址，CR3 寄存器指定页目录表的基地址。线性地址的高10位用于索引这个页目录表，以获得指向相关第二级页表的指针。线性地址空间中间10位用于索引二级页表，以获得物理地址的高20位。线性地址的第12位直接作为物理地址的第12位，从而组成一个完整的32位物理地址。 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:1:4","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Linux分页机制 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:1:5","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"第三章 进程 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:2:0","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"TaskStruct结构 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:2:1","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"进程状态 可运行状态- task running 可中断的等待状态- task interruptible 不可中断的等待状态- task uninterruptible 暂停状态- task_stopped 跟踪状态- task_traced 两种EXIT_STATE状态 僵死状态- EXIT_ZOMBIE 僵死撤销状态- EXIT_DEAD ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:2:2","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"内核栈 大小为8K，task_struct 和 thread_info 可以很方便的互相寻址 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:2:3","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"进程切换 ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:2:4","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"进程创建 clone fork vfork ","date":"2023-06-04","objectID":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/:2:5","tags":["Linux","system"],"title":"深入理解Linux内核笔记","uri":"/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"高并发系统设计的三大目标：高性能、高可用、可扩展 性能的度量指标 一般来说，度量性能的指标是系统接口的响应时间： ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:1:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"平均值 平均值是把这段时间所有请求的响应时间数据相加，再除以总请求数。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:2:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"最大值 这段时间内所有请求响应时间最长的值，但它的问题又在于过于敏感了。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:3:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"分位值 以 90 分位为例，我们把这段时间请求的响应时间从小到大排序，假如一共有 100 个请求，那么排在第 90 位的响应时间就是90 分位值。 分位值是最适合作为时间段内，响应时间统计值来使用的，在实际工作中也应用最多。 我们通常使用吞吐量或者同时在线用户数来度量并发和流量 如我们设立性能优化的目标时通常会这样表述：在每秒 1 万次的请求量下，响应时间 99 分位值在 10ms 以下。 系统怎样做到高可用？ ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:4:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"高可用性（High Availability，HA） ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:5:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"可用性的度量 MTBF（Mean Time Between Failure）是平均故障间隔的意思，代表两次故障的间隔时间，也就是系统正常运转的平均时间。这个时间越长，系统稳定性越高。 MTTR（Mean Time To Repair）表示故障的平均恢复时间，也可以理解为平均故障时间。这个值越小，故障对于用户的影响越小。 Availability = MTBF / (MTBF + MTTR) ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:5:1","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"数据库篇 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:6:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"池化技术 线程池、数据库连接池 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:6:1","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"主从读写分离 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:7:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"主从复制 MySQL 的主从复制是依赖于 binlog 的，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上二进制日志文件。主从复制就是将 binlog 中的数据从主库传输到从库上，一般这个过程是异步的，即主库上的操作不会等待 binlog 同步的完成。 首先从库在连接到主节点时会创建一个 IO 线程，用以请求主库更新的 binlog，并且把接收到的 binlog 信息写入一个叫做 relay log 的日志文件中，而主库也会创建一个 log dump 线程来发送 binlog 给从库；同时，从库还会创建一个 SQL 线程读取 relay log 中的内容，并且在从库中做回放，最终实现主从的一致性。这是一种比较常见的主从复制方式。 除了带来了部署上的复杂度，还有就是会带来一定的主从同步的延迟，这种延迟有时候会对业务产生一定的影响。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:7:1","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"如何访问数据库 中间件： TDDL 单独部署的代理层： 期阿里巴巴开源的Cobar，基于 Cobar 开发出来的 Mycat，360 开源的 Atlas，美团开源的基于 Atlas 开发的 DBProxy 等等 分库分表 分库分表是一种常见的将数据分片的方式，它的基本思想是依照某一种策略将数据尽量平均的分配到多个数据库节点或者多个表中。 数据库分库分表的方式有两种：一种是垂直拆分，另一种是水平拆分。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:8:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"如何对数据库做垂直拆分 垂直拆分，顾名思义就是对数据库竖着拆分，也就是将数据库的表拆分到多个不同的数据库中。垂直拆分的原则一般是按照业务类型来拆分，核心思想是专库专用，将业务耦合度比较高的表拆分到单独的库中。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:9:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"如何对数据库做水平拆分 水平拆分指的是将单一数据表按照某一种规则拆分到多个数据库和多个数据表中，关注点在数据的特点。 按照某一个字段的哈希值做拆分，这种拆分规则比较适用于实体表，比如说用户表，内容表，我们一般按照这些实体表的 ID 字段来拆分。 另一种比较常用的是按照某一个字段的区间来拆分，比较常用的是时间字段。你知道在内容表里面有“创建时间”的字段，而我们也是按照时间来查看一个人发布的内容。我们可能会要看昨天的内容，也可能会看一个月前发布的内容，这时就可以按照创建时间的区间来分库分表，比如说可以把一个月的数据放入一张表中，这样在查询时就可以根据创建时间先定位数据存储在哪个表里面，再按照查询条件来查询。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:9:1","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"分库分表引入的问题 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:9:2","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"如何保证分库分表后ID的全局唯一性？ 使用业务字段作为主键，比如说对于用户表来说，可以使用手机号，email 或者身份证号作为主键。 使用生成的唯一 ID 作为主键。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:10:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"snowflake 雪花算法 可在分布式环境下用于生成唯一ID的算法。该算法生成的是一个64位的ID，故在Java下正好可以通过8字节的long类型存放。所生成的ID结构如下所示 41位长度的时间戳可以保证使用69年 最低的12位为序列号，可用于标识、区分同一个计算机在相同毫秒时间内的生产的ID 缓存篇 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:10:1","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"缓存使用策略 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:11:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"cache aside Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:11:1","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Read/Write Through（读穿 / 写穿）策略 Write Through 的策略是这样的：先查询要写入的数据在缓存中是否已经存在，如果已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，如果缓存中数据不存在，我们把这种情况叫做“Write Miss（写失效）”。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:11:2","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Write Back（写回）策略 这个策略的核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:11:3","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"分布式缓存高可用 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:12:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"客户端：缓存数据如何分片 Hash 分片算法 一致性 Hash 算法 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:12:1","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"代理层 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:12:2","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"服务端方案 redis sentinel 所有缓存的读写请求都是经过代理层完成的。代理层是无状态的，主要负责读写请求的路由功能，并且在其中内置了一些高可用的逻辑，不同的开源中间代理层方案中使用的高可用策略各有不同。比如在 Twemproxy 中，Proxy 保证在某一个 Redis 节点挂掉之后会把它从集群中移除，后续的请求将由其他节点来完成；而 Codis 的实现略复杂，它提供了一个叫 Codis Ha 的工具来实现自动从节点提主节点，在 3.2 版本之后换做了 Redis Sentinel 方式，从而实现 Redis 节点的高可用。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:12:3","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"缓存穿透 缓存穿透其实是指从缓存中没有查到数据，而不得不从后端系统（比如数据库）中查询的情况。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:13:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"回种空值 当我们从数据库中查询到空值或者发生异常时，我们可以向缓存中回种一个空值。但是因为空值并不是准确的业务数据，并且会占用缓存的空间，所以我们会给这个空值加一个比较短的过期时间，让空值在短时间之内能够快速过期淘汰。回种空值虽然能够阻挡大量穿透的请求，但如果有大量获取未注册用户信息的请求，缓存内就会有有大量的空值缓存，也就会浪费缓存的存储空间，如果缓存空间被占满了，还会剔除掉一些已经被缓存的用户信息反而会造成缓存命中率的下降。 是一种最常见的解决思路，实现起来也最简单，如果评估空值缓存占据的缓存空间可以接受，那么可以优先使用这种方案； ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:13:1","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"布隆过滤器 布隆过滤器会引入一个新的组件，也会引入一些开发上的复杂度和运维上的成本。所以只有在存在海量查询数据库中，不存在数据的请求时才会使用，在使用时也要关注布隆过滤 器对内存空间的消耗； ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:13:2","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"设置分布式锁 通过在 Memcached 或者 Redis 中设置分布式锁，只有获取到锁的请求才能够穿透到数据库。 对于极热点缓存数据穿透造成的“狗桩效应”，可以通过设置分布式锁或者后台线程定时加载的方式来解决。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:13:3","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"CDN加速 CDN（Content Delivery Network/Content Distribution Network，内容分发网络）。 消息队列篇 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:14:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"秒杀场景 削峰填谷 将秒杀请求暂存在消息队列中，然后业务服务器会响应用户“秒杀结果正在计算中”，释放了系统资源之后再处理其它用户的请求 通过异步处理简化秒杀请求中的业务流程 服务解耦合 分布式服务篇 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:15:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"RPC框架 的序列化备选方案主要有以下几种： JSON、XML Thrift、Protobuf，需要引入IDL文件 Thrift 是 Facebook 开源的高性能的序列化协议，也是一个轻量级的 RPC 框架； Protobuf 是谷歌开源的序列化协议。它们的共同特点是，无论在空间上还是时间上都有着很高的性能，缺点就是由于 IDL 存在带来一些使用上的不方便。 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:16:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"注册中心 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:17:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"负载均衡 LVS：四层负载 NGINX：七层负载均衡 分库分表-\u003e缓存-\u003e消息队列-\u003e微服务化 ","date":"2023-05-20","objectID":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/:18:0","tags":["Linux","system"],"title":"高并发系统设计学习笔记","uri":"/posts/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"STL vector 支持 size() empty() clear() 清空 front()/back() 数组头尾元素 push_back()/pop_back begin()/end() 首尾元素 支持字典序比较 pair first 第一个元素 second 第二个元素 string size()/length 返回长度 empty() clear() substr(a,b) 得到一个下标位a长度位b的子字符串 substr(a) 得到一个下表为a长度取最长的子字符串 c_str() 取string定义数组的首地址 queue size() empty() push() 在队尾插入一个元素 front()/back() 返回队头/队尾元素 pop() 弹出队头元素 priority_queue 优先队列(堆) 默认大根堆 size() empty() push() top() pop() 定义小根堆: priority_queue\u003cint , vector\u003cint\u003e , greater\u003cint\u003e\u003e stack size() empty() push() pop() top() deque 支持[] size() empty() clear() front()/back() 头尾元素 push_back()/push_front() 在头尾插入 begin()/end() set , map , multimap , multiset , 基于平衡二叉树 (红黑树) 维护一个有序数列 大部分函数时间复杂度都是logn (因为是树) size() empty() clear() begin()/end() 支持++ -- 时间复杂度 O(logn) lower_bound()/upper_bound() lower_bound(x) 返回一个大于等于x的最小值 upper_bound(x) 返回一个大于x的最小值 set / multiset set不支持重复数插入 插入重复数直接跳过 insert() 插入一个数 find() 查找一个数 count() 返回一个数存入的个数 erase() (1) 输入是一个x , 删除全部x , 时间复杂度 O(k + logn) (2) 输入是一个迭代器 , 删除这个迭代器 map / multimap insert() 插入的是一个pair erase() 输入的参数是pair 或者 迭代器 find() 支持[] unordered_set , unordered_map , unordered_multiset , unordered_multimap 基本跟上面一个一样 查找删改时间复杂度是 O(1) 不支持lower_bound()/upper_bound() 迭代器的++ -- bitset 压位 bitset\u003c放大小\u003e s; 初始化时候全为0 —— false; ~取反 \u0026且 |或 ^异或 == , != 移位 \u003c\u003c \u003e\u003e 支持[] count() 返回有多少个1 any() 判断是否有1 none() 判断是否全为0 set() 把所有位置为1 set(k,v) 将第k位变成v reset() 把所有位置为0 flip() 等价于~ flip(x) 第k位取反 基础算法 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:0:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"快速排序 const int N = 1e6 + 10; int n; int q[N]; void quick_sort(int *q,int l,int r) { if (l \u003e= r) return; int x = q[l+r\u003e\u003e1], i = l-1, j = r + 1; while (i \u003cj) { do i++; while (q[i] \u003c x); do j--; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j+1 , r); } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:1:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"归并排序 const int N = 1e6 + 10; int n; int q[N], tmp[N]; void merge_sort(int q[],int l,int r) { if (l \u003e= r) return; int mid = l + r \u003e\u003e 1; merge_sort(q, l, mid), merge_sort(q, mid+1, r); int k = 0, i = l, j = mid +1; while (i \u003c= mid \u0026\u0026 j \u003c= r) if (q[i] \u003c= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; while (i \u003c= mid) tmp[k++] = q[i++]; while (j \u003c= r) tmp[k++] = q[j++]; for (i = l, j = 0; i\u003c= r; i++, j++) q[i] = tmp[j]; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:2:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"二分 AcWing 789. 图解 y总的二分模板 （最容易理解版本 ) - AcWing //查找左边界 SearchLeft 简写SL int SL(int l, int r) { while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } //查找右边界 SearchRight 简写SR int SR(int l, int r) { while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; //需要+1 防止死循环 if (check(mid)) l = mid; else r = mid - 1; } return r; } 704 35 34 69 367 STL 数据结构 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:3:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"单链表 #include\u003ciostream\u003e using namespace std; const int N = 100000; int e[N], ne[N]; int head, idx; void init() { head = -1; idx = 0; } void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx++; } void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx++; } void remove(int k) { ne[k] = ne[ne[k]]; } int main() { int m; cin \u003e\u003em; init(); while(m--) { int k, x; char op; cin \u003e\u003e op; if (op == 'H') { cin \u003e\u003e x; add_to_head(x); } else if (op == 'D') { cin \u003e\u003e k; if(!k) head = ne[head]; remove(k-1); } else { cin \u003e\u003e k \u003e\u003e x; add (k-1, x); } // cout \u003c\u003c op \u003c\u003c endl; } for (int i = head; i!= -1; i = ne[i]) cout \u003c\u003c e[i] \u003c\u003c ' '; cout \u003c\u003c endl; return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:4:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"双链表 const int N = 100000; int e[N], ne[N]; int head, idx; void init() { head = -1; idx = 0; } void add_to_head(int x) { e[idx] = x, ne[idx] = head, head = idx++; } void add(int k, int x) { e[idx] = x, ne[idx] = ne[k], ne[k] = idx++; } void remove(int k) { ne[k] = ne[ne[k]]; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:5:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"栈 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:6:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"单调栈 #include \u003ciostream\u003e using namespace std; const int N = 100010; int n ; int skt[N], tt; int main () { cin \u003e\u003e n; for (int i = 0; i\u003c n; i++) { int x; cin \u003e\u003e x; while (tt \u0026\u0026 skt[tt] \u003e= x) tt--; if (tt) cout \u003c\u003c skt[tt] \u003c\u003c \" \"; else cout \u003c\u003c -1 \u003c\u003c \" \"; skt[++tt] = x; } return 0; } 单调递增：小于，单调递减：大于 class Solution { public: int sumSubarrayMins(vector\u003cint\u003e\u0026 arr) { int n = arr.size(); vector\u003cint\u003e left(n, -1), right(n, -1); stack\u003cint\u003e skt1; // ++ for (int i = 0; i \u003c n; ++ i) { while (!skt1.empty() \u0026\u0026 arr[skt1.top()] \u003e= arr[i]) { right[skt1.top()] = i; skt1.pop(); } left[i] =skt1.empty()? -1: skt1.top(); skt1.push(i); } for (int i = 0; i \u003c n; ++ i) { cout \u003c\u003c left[i] \u003c\u003c \" \"; } cout \u003c\u003c endl; for (int i = 0; i \u003c n; ++ i) { cout \u003c\u003c right[i] \u003c\u003c \" \"; } return 1; } }; ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:7:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"单调队列 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:8:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"优先队列 #include\u003cbits/stdc++.h\u003e using namespace std; // 自定义比较函数，需重载 () 运算符 struct cmp { bool operator() (pair\u003cint, int\u003e \u0026a, pair\u003cint, int\u003e \u0026b) { return a.first \u003e b.first; // 小根堆 } }; // 自定义数据结构，需重载 \u003c 运算符 struct Info { int h_; Info(int h) : h_(h) {} bool operator\u003c(const Info\u0026 t) const // 不加const会报错！ { return h_ \u003e t.h_; // 小根堆 } }; int main() { // 默认大根堆, 第三个参数 less\u003cint\u003e 可以不加 priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e\u003e q1; // 小根堆 priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q2; // 自定义比较函数 priority_queue\u003cpair\u003cint, int\u003e, vector\u003cpair\u003cint, int\u003e\u003e, cmp\u003e q3; // 自定义数据类型 priority_queue\u003cInfo, vector\u003cInfo\u003e\u003e q4; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:9:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"KMP https://www.acwing.com/blog/content/2347/ const int N = 100010, M= 1000010; int n, m; char p[N], s[M]; int ne[N]; int main() { cin \u003e\u003e n \u003e\u003e p + 1 \u003e\u003e m \u003e\u003e s + 1; // get next array for (int i = 2, j = 0; i \u003c= n; i++) { while (j \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j+1]) j++; ne[i] = j; } for (int i = 1, j = 0; i \u003c= m; i++) { while (j \u0026\u0026 s[i] != p[j +1]) j = ne[j]; if (s[i] == p[j+1]) j++; if (j == n) { // match success printf(\"%d \", i- n); j = ne[j]; } } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:10:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"Trie const int N = 100010; int son[N][26], cnt[N], idx; // 下标是0的点，即是根节点，又是空节点 void insert(const char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++idx; p = son[p][u]; } cnt[p]++; } int query(const char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:11:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"并查集 https://www.acwing.com/problem/content/description/838/ #include \u003ciostream\u003e using namespace std; const int N = 100010; int n,m; int p[N]; // 返回x祖宗节点 + 路径压缩 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) p[i] = i; while (m--) { char op[2]; int a,b; scanf(\"%s%d%d\", op, \u0026a, \u0026b); if (op[0] == 'M') p[find(a)] = find(b); else { if (find(a) == find(b)) puts(\"Yes\"); else puts(\"No\"); } } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:12:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"堆 堆排序 https://www.acwing.com/problem/content/840/ // // Created by zhuzhicheng on 2022/8/28. // 838. 堆排序 // https://www.acwing.com/problem/content/840/ #include \u003cbits/stdc++.h\u003e using namespace std; const int N = 100010; int n, m; int h[N], cnt; void down(int u) { int t = u; if (u * 2 \u003c= cnt \u0026\u0026 h[u * 2] \u003c h[t]) t = u * 2; if (u * 2 + 1 \u003c= cnt \u0026\u0026 h[u * 2 + 1] \u003c h[t]) t = u * 2 + 1; if (u != t) { swap(h[u], h[t]); down(t); } } void up(int u) { while (u / 2 \u0026\u0026 h[u / 2] \u003e h[u]) { swap(h[u / 2], h[u]); u /= 2; } } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; ++i) { scanf(\"%d\", \u0026h[i]); } cnt = n; // for (int i = 1; i \u003c= n / 2; ++i) down(i); for (int i = n / 2; i; i--) down(i); while (m--) { printf(\"%d \", h[1]); h[1] = h[cnt--]; down(1); } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:13:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"线段树 关于线段树 - AcWing 模拟堆c 数学知识 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:14:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"质数 试除法 #include \u003ciostream\u003e using namespace std; bool is_prime(int n) { if (n \u003c 2) return false; for (int i = 2; i \u003c= n / i; i++) { if (n % i == 0) return false; } return true; } int main () { int n; cin \u003e\u003e n; for (int i = 0; i\u003c n; i++) { int x; cin \u003e\u003e x; if(is_prime(x)) puts(\"Yes\"); else puts(\"No\"); } return 0; } 分解质因数 质因数（素因数或质因子）在数论里是指能整除给定正整数的质数。 #include \u003ciostream\u003e using namespace std; void divide(int n) { for (int i = 2; i \u003c= n/i; i++) { if (n % i == 0) { // i 一定是质数 int s = 0; while(n % i == 0) { n /= i; s ++; } printf(\"%d %d\\n\", i, s); } } if (n \u003e 1) printf(\"%d %d\\n\", n, 1); cout \u003c\u003c \"\\n\"; } int main () { int n; cin \u003e\u003e n; for (int i = 0; i\u003c n; i++) { int x; cin \u003e\u003e x; divide(x); } return 0; } 筛质数(埃shi筛法) https://www.acwing.com/solution/content/7950/ #include \u003ciostream\u003e using namespace std; const int N = 1000010; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i =2; i \u003c= n; i++) { if (!st[i]) { primes[cnt ++] = i; for (int j = i; j \u003c= n; j += i) st[j] = true; } } } int main() { int n; cin \u003e\u003e n; get_primes(n); cout \u003c\u003c cnt; return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:15:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"约数 试除法 #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e using namespace std; vector\u003cint\u003e get_divisions(int n) { vector\u003cint\u003e res; for (int i = 1; i \u003c= n / i; i++) if (n % i == 0) { res.push_back(i); if (i != n / i) res.push_back(n / i); } sort(res.begin(), res.end()); return res; } int main() { int n; cin \u003e\u003e n; for (int i = 0; i \u003c n; i++) { int x; cin \u003e\u003e x; auto res = get_divisions(x); for (auto t : res) cout \u003c\u003c t \u003c\u003c \" \"; cout \u003c\u003c endl; } return 0; } 约数个数 $N=P1^{\\alpha 1}.P2^{\\alpha 2}.P3^{\\alpha 3}…Pk^{\\alpha k}$ 约数个数为 $$(\\alpha 1+1)(\\alpha 2+1)(\\alpha 3+1)…(\\alpha k+1)$$ #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e #include\u003cunordered_map\u003e using namespace std; typedef long long LL; const int mod = 1e9 + 7; int main() { int n; cin \u003e\u003e n; unordered_map\u003cint, int\u003e primes; while (n--) { int x; cin \u003e\u003e x; for (int i = 2; i \u003c= x / i; i++) while (x % i == 0) { x /= i; primes[i] ++; } if (x \u003e 1) primes[x] ++; } LL res = 1; for (auto prime : primes) res = res * (prime.second + 1) % mod; cout \u003c\u003c res; return 0; } 约数之和为$$(P1^0+ P1^1+P1^2+…+P1^{\\alpha 1})…(Pk^0+ Pk^1+Pk^2+…+Pk^{\\alpha k})$$ #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e #include\u003cunordered_map\u003e using namespace std; typedef long long LL; const int mod = 1e9 + 7; int main() { int n; cin \u003e\u003e n; unordered_map\u003cint, int\u003e primes; while (n--) { int x; cin \u003e\u003e x; for (int i = 2; i \u003c= x / i; i++) while (x % i == 0) { x /= i; primes[i] ++; } if (x \u003e 1) primes[x] ++; } LL res = 1; for (auto prime : primes) { int p = prime.first; int a = prime.second; LL t = 1; while (a--) t = (t * p + 1) % mod; res = res * t % mod; } cout \u003c\u003c res; return 0; } 最大公约数（欧几里得算法） #include \u003ciostream\u003e using namespace std; int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int main() { int n; cin \u003e\u003e n; while (n--) { int a, b; cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c gcd(a, b) \u003c\u003c endl; } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:16:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"欧拉函数 1∼N 中与 N 互质（最大公约数为1）的数的个数被称为欧拉函数，记为 ϕ(N)。 https://www.acwing.com/solution/content/8702/ #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; int main() { int n; cin \u003e\u003e n; while (n--) { int a; cin \u003e\u003e a; int res = a; for (int i = 2; i \u003c= a / i; i++ ) { if (a % i == 0) { res = res / i * (i - 1); while (a % i == 0) a /= i; } } if (a \u003e 1) res = res / a * (a - 1); cout \u003c\u003c res \u003c\u003c endl; } return 0; } 筛法求欧拉函数 给定一个正整数n，求1~n中每个数的欧拉函数之和。 https://www.acwing.com/solution/content/3952/ #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; typedef long long LL; const int N = 1000010; int primes[N], cnt; int phi[N]; bool st[N]; LL get_eulers(int n) { phi[1] = 1; for (int i = 2; i \u003c= n; ++ i) { if (!st[i]) { primes[cnt ++] = i; phi[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; ++ j) { st[primes[j] * i] = true; if (i % primes[j] == 0) { phi[primes[j] * i] = primes[j] * phi[i]; break; } phi[primes[j] * i] = (primes[j] - 1) * phi[i]; } } LL res = 0; for (int i = 1; i \u003c= n; ++ i) { res += phi[i]; } return res; } int main() { int n; cin \u003e\u003e n; cout \u003c\u003c get_eulers(n) \u003c\u003c endl; return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:17:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"快速幂 #include\u003ciostream\u003e using namespace std; using LL = long long; LL qmi(LL a, int b, int p) { LL res = 1; while(b) { if (b\u00261) res = res * a % p; b \u003e\u003e= 1; a = a*a %p; } return res; } int main() { int n; cin\u003e\u003en; while(n--) { int a,b,p; long long res=1; cin\u003e\u003ea\u003e\u003eb\u003e\u003ep; cout \u003c\u003c qmi(a,b,p) \u003c\u003cendl;; } return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:18:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"欧几里得算法 (辗转相除法) ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:19:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"中国剩余定理 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:20:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"高斯消元 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:21:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"求组合数 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:22:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"容斥原理 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:23:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"博弈论 拆分Nim游戏 #include \u003ciostream\u003e #include \u003calgorithm\u003e #include \u003ccstring\u003e #include \u003cunordered_set\u003e using namespace std; const int N = 110; int f[N]; int sg(int x) { if (f[x] != -1) return f[x]; unordered_set\u003cint\u003e S; for (int i = 0; i \u003c x; i++) for (int j = 0; j \u003c= i; j++) { S.insert(sg(i) ^ sg(j)); } // mex op for (int i = 0;; i++) if (!S.count(i)) return f[x] = i; } int main() { int n ; cin \u003e\u003e n; memset(f, -1, sizeof f); int res = 0; for (int i = 0; i \u003c n; i++) { int x; cin \u003e\u003e x; res ^= sg(x); } if (res) puts(\"Yes\"); else puts(\"No\"); return 0; } 搜索与图论 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:24:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"图的定义问题 微信公众平台 邻接矩阵 这是一种使用二维矩阵来进行存图的方式。 适用于边数较多的**「稠密图」使用，当边数量接近点的数量的平方，即 时，可定义为「稠密图」**。 // 邻接矩阵数组：w[a][b] = c 代表从 a 到 b 有权重为 c 的边 int[][] w = new int[N][N]; // 加边操作 void add(int a, int b, int c) { w[a][b] = c; } 邻接表 这也是一种在图论中十分常见的存图方式，与数组存储单链表的实现一致（头插法）。 这种存图方式又叫**「链式前向星存图」**。 适用于边数较少的**「稀疏图」使用，当边数量接近点的数量，即 时，可定义为「稀疏图」**。 int N = 110, M = 6010; int[] he = new int[N], e = new int[M], ne = new int[M], w = new int[M]; int idx; void add(int a, int b, int c) { e[idx] = b; ne[idx] = he[a]; he[a] = idx; w[idx] = c; idx++; } 首先 idx 是用来对边进行编号的，然后对存图用到的几个数组作简单解释： he 数组：存储是某个节点所对应的边的集合（链表）的头结点； e 数组：由于访问某一条边指向的节点； ne 数组：由于是以链表的形式进行存边，该数组就是用于找到下一条边； w 数组：用于记录某条边的权重为多少。 因此当我们想要遍历所有由 a 点发出的边时，可以使用如下方式： for (int i = he[a]; i != -1; i = ne[i]) { int b = e[i], c = w[i]; // 存在由 a 指向 b 的边，权重为 c } 类 这是一种最简单，但是相比上述两种存图方式，使用得较少的存图方式。 只有当我们需要确保某个操作复杂度严格为O(m) 时，才会考虑使用。 具体的，我们建立一个类来记录有向边信息： class Edge { // 代表从 a 到 b 有一条权重为 c 的边 int a, b, c; Edge(int _a, int _b, int _c) { a = _a; b = _b; c = _c; } } 通常我们会使用 List 存起所有的边对象，并在需要遍历所有边的时候，进行遍历： List\u003cEdge\u003e es = new ArrayList\u003c\u003e(); ... for (Edge e : es) { ... } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:25:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"dfs https://www.acwing.com/problem/content/844/ const int N = 10; int path[N]; int sts[N]; int n; void dfs(int u) { if (u == n) { for (int i = 0 ;i \u003c n; i++) cout \u003c\u003c path[i] \u003c\u003c \" \"; puts(\" \"); return; } for (int i = 0 ;i \u003c n; i++) { if (sts[i] != 1) { path[u] = i + 1; sts[i] = 1; dfs(u+1); sts[i] = 0; } } } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:26:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"八皇后 https://www.acwing.com/problem/content/845/ solve: https://www.acwing.com/solution/content/2820/ #include \u003ciostream\u003e using namespace std; const int N = 10; int n; bool col[N], dg[N], udg[N]; char g[N][N]; void dfs(int u) { if (u == n) { for (int i = 0; i \u003c n; i++) puts(g[i]); puts(\" \"); return; } for (int i = 0; i \u003c n; i++) { if(!col[i] \u0026\u0026 !dg[u + i] \u0026\u0026 !udg[n-u+i]) { g[u][i] = 'Q'; col[i] = dg[u+i] = udg[n-u+i] = true; dfs(u+1); col[i] = dg[u+i] = udg[n-u+i] = false; g[u][i] = '.'; } } } int main() { cin \u003e\u003e n; for (int i = 0; i\u003c n; i++) { for (int j = 0; j\u003c n; j++) { g[i][j] = '.'; } } dfs(0); return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:26:1","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"bfs https://www.acwing.com/problem/content/description/846/ https://www.acwing.com/solution/content/2078/ #include \u003ciostream\u003e #include \u003cqueue\u003e using namespace std; const int N = 102; int g[N][N], d[N][N]; int n, m; using PII = pair\u003cint,int\u003e; int bfs() { queue\u003cPII\u003e q; for(auto \u0026v: d) for (auto \u0026x :v) { x = -1; } d[0][0] = 0; q.push({0,0}); int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1}; while(!q.empty()) { auto t = q.front(); q.pop(); for (int i = 0 ; i \u003c 4; i++) { int x = t.first + dx[i], y = t.second + dy[i]; if (x \u003e= 0 \u0026\u0026 x \u003c n \u0026\u0026 y \u003e= 0 \u0026\u0026 y \u003c m \u0026\u0026 g[x][y] == 0 \u0026\u0026 d[x][y] == -1) { d[x][y] = d[t.first][t.second] + 1; q.push({x,y}); } } } return d[n-1][m-1]; } int main() { cin \u003e\u003e n \u003e\u003e m; for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c m; j++) { cin \u003e\u003e g[i][j]; } } cout \u003c\u003c bfs() \u003c\u003c endl; return 0; } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:27:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"树的bfs https://www.acwing.com/solution/content/13513/ （数组建立邻接表） 树的dfs //邻接表 int h[N], e[N * 2], ne[N * 2], idx; void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } 树的bfs模板 // 需要标记数组st[N], 遍历节点的每个相邻的便 void dfs(int u) { st[u] = true; // 标记一下，记录为已经被搜索过了，下面进行搜索过程 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { dfs(j); } } } ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:28:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"树的dfs 差分与前缀和 前缀和与差分 图文并茂 超详细整理（全网最通俗易懂）_前缀和差分_林小鹿@的博客-CSDN博客 动态规划 ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:29:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"背包问题 LFU \u0026\u0026 LRU ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:30:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"LFU ","date":"2022-04-29","objectID":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/:31:0","tags":["algorithm","template"],"title":"算法模板整理","uri":"/posts/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/"},{"categories":null,"content":"Nvidia（英伟达）于2020年收购Mellanox公司（专注于提供IB网络、Ethernet网络产品，如ConnectX系列网卡），并在同年推出BlueField DPU，自此，DPU成为芯片领域一个新的聚焦点，Marvell、Pensando、Broadcom（博通）、Intel等国外传统半导体/芯片公司纷纷入局，国内的中科驭数、星云智联等芯片公司和一大批初创公司也提出了自己的DPU方案。 Nvidia CEO 黄仁勋在 GTC（GPU技术大会）上提出：“用于通用计算的 CPU，用于加速计算的 GPU，用于网络数据处理的 DPU，将成为未来计算的三大支柱”[1]。究竟什么是 DPU？为什么它将有可能与传统的 CPU、GPU平起平坐呢？ ","date":"2021-12-29","objectID":"/posts/dpu/:0:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"一、DPU是什么 数据处理单元（Data Processing Unit），通常称为DPU，是一种新型的可重新编程的结合高性能网络接口的高性能处理器。这些网络接口经过优化，可以执行和加速由数据中心服务器执行的网络和存储功能[2]。DPU就像GPU一样插入服务器的PCIe插槽，它们允许服务器将网络和存储功能从CPU卸载到DPU，让CPU只专注于运行操作系统和系统应用程序。DPU通常使用可重新编程的FPGA结合网络接口卡来加速网络流量，就像使用GPU通过将数学运算从CPU卸载到GPU来加速人工智能(AI)应用程序一样。 ","date":"2021-12-29","objectID":"/posts/dpu/:1:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"二、DPU的产生与发展 网络的发展推动着DPU的出现，DPU的发展史也是网卡的发展史。 ","date":"2021-12-29","objectID":"/posts/dpu/:2:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"第⼀阶段：基础功能网卡 基础功能网卡即传统网卡只提供了最基础的网络接口，通过PCIE等总线，作为主机和外部网络连接的桥梁。基础网卡一般提供2x10G或2x25G带宽吞吐能力，网络的TCP/IP协议栈的处理由主机的操作系统实现，其硬件卸载能力较弱，主要是Checksum，LRO/LSO等，支持SR-IOV（Single Root I/O Virtualization），以及有限的多队列能力。 ","date":"2021-12-29","objectID":"/posts/dpu/:2:1","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"第⼆阶段：智能网卡 借助软硬件融合的思想，将操作系统的部分网络协议栈（TCP/IP、VLAN、GENEVE）由硬件来实现，实现对于各种网络基础功能的支持和加速，从而释放CPU的通用算力，由此诞生了各种offload NIC（支持卸载的网卡）。随着网络协议的复杂化和多样化，固定协议的offload无法与网络协议的快速更新发展相匹配，经历1-2年研发周期的固化网卡面临着被迅速淘汰的危机，在这样的背景下就要求网卡具有一定的可编程能力，从而满足协议更新的需求，延长网卡的市场周期。我们把拥有可编程能力的硬件卸载网卡叫做SmartNIC（智能网卡），它具有更加丰富的硬件卸载能力和一定的可编程性支持，如：OVS Fastpath硬件卸载，基于RoCE和RoCEv2的RDMA网络硬件卸载，融合网络中无损网络能力（PFC，ECN，ETS等）的硬件卸载，存储领域NVMe-oF（NVMe-over-Fabrics）的硬件卸载，以及安全传输的数据面卸载等。此时期的智能网卡以数据平面的卸载为主。 ","date":"2021-12-29","objectID":"/posts/dpu/:2:2","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"第三阶段：DPU智能⽹卡 DPU可以看作是第二代智能网卡，它在第一代智能网卡的基础上加入了片上CPU Core（ARM/MIPS），可以卸载控制平面的任务和一些灵活复杂的数据平面任务，有更强的可编程性。DPU主要分为网络单元和计算单元，网络单元负责与片上CPU、外设、主机的连接，计算单元赋予了DPU通用计算能力，与各种硬件加速器协同实现各种计算任务的加速，如DPI（深度包解析）、RegEx（正则匹配）、IPSec/AES（加密）等。DPU的出现使得网卡的卸载不再局限于网络功能，在网络、计算、存储、安全各个方面都有了更加丰富的支持。目前DPU智能网卡支持PCIe Root Complex模式和Endpoint模式，在配置为PCIe Root Complex模式时，可以实现NVMe存储控制器，与NVMe SSD磁盘一起构建存储服务器。 ","date":"2021-12-29","objectID":"/posts/dpu/:2:3","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"三、DPU的优势 DPU的功能主要包括了网络、计算、存储、安全多个方面。 基于网卡发展而来的DPU，其最核心的功能集中在网络方面，可以用于卸载网络虚拟化（OVS等）、SR-IOV、防火墙或任何其他需要高速数据包处理的应用程序。目前，主流的DPU支持高达200Gb/s的以太网和InfiniBand网络处理，释放CPU算力，从而解决主机上计算密集型应用的性能瓶颈。 对于存储，DPU可以作为标准的NVMe设备呈现给主机系统，同时它可以采用NVMe-oF解决方案，使用来自数据中心其他服务器的远程NVMe存储器。DPU也可以直接通过PCIe连接NVMe SSD，然后通过网络暴露给数据中心的其他DPU，所有这些活动都不需要传统的主机服务器的参与。DPU可以卸载NVMe-oF存储直连、加密、弹性存储、数据完整性、压缩和去重等，这使得远程存储的延迟与性能和直连存储相接近，提供了构建数据中心的高性能池化存储的新方式。 对于计算，DPU可用于运行与服务器上的主管理程序不同的管理程序，从而使x86 CPU或GPU甚至FPGA成为另一种跨越整个数据中心多台服务器的集中资源。或者只是将这些资源直接连接到DPU，由DPU将它们暴露到网络上。这样以来，数据中心内的任何主机都可以访问各种处理引擎的资源，任何主机上的任何应用程序都可以自由地利用这些加速器，无论它们实际物理位置在哪里。 在数据中心 “以数据为中心” 的趋势下，DPU为云服务提供商提供了资源池化的新方式，使其能够在基础架构内的任何位置组合存储、网络和计算资源，实现按需分配，进一步提高资源的利用率，为数据中心降低成本，达到更高的经济效益。此外，通过将安全任务卸载到DPU上，云服务提供商能够在为云租户提供裸机即服务（bare-metal-as-a-service）的同时保证服务环境的正确性与安全性。AWS/阿里云纷纷自研，英特尔/英伟达竞相布局，DPU已经在各大数据中心展现出巨大的价值。 ","date":"2021-12-29","objectID":"/posts/dpu/:3:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"四、DPU的核心要素 DPU SoC的核心并不是一个高性能的嵌入式CPU，由于能耗限制，期待DPU的嵌入式CPU达到比主机CPU更强的数据处理能力是不现实的。对于传统的x86CPU来说，100Gb/s的数据包处理速度已经会带来巨大的处理负担，极端情况下甚至会导致数据包的堆积和丢失。在400Gb/s的高速网络下，期待DPU的低功耗嵌入式CPU去处理每个数据包并不是一个合理的解决方案。Nvidia的Bluefield DPU和Pensando的Elba DPU解决方案都表明，在数据包处理负担过重的情况下，由嵌入式CPU负责控制路径的初始化和异常情况的处理可能是更好的DPU实现方式。 DPU在架构上主要包含两个部分。首先是继承于智能网卡的网络处理单元，例如Nvidia Bluefield DPU集成了ConnectX-6网卡单元，Pensando的Elba DPU集成了P4的数据包处理流水线。网络处理单元具有高性能的网络接口，用来连接外部高速网络，目前的主流DPU产品支持100Gb/s~200Gb/s的网络接口，未来两到三年会逐步提升至400Gb/s甚至800Gb/s的水平。第二个部分是SoC，主要包含低功耗的嵌入式CPU和各种HAC（Hardware Accelerator）。嵌入式CPU通常会使用ARM核或者其他的低功耗处理器（Fungible使用了MIPS 64处理器）以控制DPU的整体功耗。有了嵌入式CPU的支撑，DPU都会运行完整一个完整的操作系统（通常是完整的Linux），带来了很强的可编程性，并配合各种灵活可编程的加速引擎用来提供更强的卸载和加速能力。 为了灵活使用DPU上的各种加速器，厂商通常会提供相应的SDK（通常会与开源生态相兼容），Nvidia DPU就提供了DOCA（Data-Center-Infrastructure-On-A-Chip Architecture）SDK来实现更加灵活便捷的硬件控制方式和编程手段，并集成P4、DPDK等，以利用开源生态。简单来说，DOCA于DPU就像CUDA于GPU，这也是Nvidia将DPU和CPU、GPU列为未来的三大计算支撑的一个着力点。 ","date":"2021-12-29","objectID":"/posts/dpu/:4:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"五、DPU解决方案 我们选择了几种主流的DPU产品对其配置和架构做简单的介绍： ","date":"2021-12-29","objectID":"/posts/dpu/:5:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"1、Nvidia Bluefield-2 Nvidia于2020年收购Mellanox，同年推出基于ConnectX网卡的BlueField DPU产品，并于2021年推出了Bluefield-2 DPU产品。BlueField-2 DPU在ConnectX-6的基础上增加了SoC部分，由嵌入式CPU处理控制平面，CX6的eSwitch处理数据平面，从而构建完整的DPU处理单元。 BlueField-2的主要规格如下： CPU：8x ARM A72核 内存控制器：8Gb 或 16Gb DDR4-3200内存 高速网络连接：2x100Gbps或1x 200Gbps以太网或InfiniBand，基于Mellanox ConnectX-6 Dx 高速数据包处理加速：类似于其他ConnectX-6 Dx解决方案的多个卸载引擎和eSwitch流逻辑 加速器：用于正则表达式、重复数据删除和压缩算法以及加密卸载 PCIe Gen4通道：16通道PCIe Gen3/4 PCIe switch 安全和管理功能：Hardware RoT（Root of Trust），具有用于带外（out-of-band）管理的1GbE接口 运行的操作系统：许多Linux发行版，如Ubuntu、CentOS、Yocoto以及VMware ESXi ","date":"2021-12-29","objectID":"/posts/dpu/:5:1","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"2、Fungible F1 Fungible是首批为其提供的这种新型处理器命名为DPU的公司之一。 Fungible F1主要规格如下： CPU：8个4x SMT MIPS-64核心的数据集群 内存控制器：2x DDR4控制器加上对8GB HBM2（High Bandwidth Memory）的支持 高速网络连接：2x 400Gbps网络接口，能够聚合高达800Gbps或8x 100GbE 高速数据包处理加速：用于解析、封装、解封装、查找和传输/接收加速的类P4语言 加速器：多个加速器，包括用于数据移动的加速器 PCIe Gen4通道：四个x16主机单元，可以作为根或端点运行 安全和管理功能：4核x2路SMT控制集群，具有安全区域、安全启动和Hardware RoT（Root of Trust），还有加密引擎和随机数生成等功能 运行的操作系统：Linux ","date":"2021-12-29","objectID":"/posts/dpu/:5:2","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"3、Pensando Elba Pensando是一家云创业公司，由一群著名的前思科工程师创立。Elba DPU由嵌入式CPU处理控制平面，P4流水线处理数据平面。 pensando Elba主要规格如下： CPU：16个ARM A72核 内存控制器：双通道DDR4/DDR5内存支持8–64GB。Pensando在之前的型号中使用HBM，但后来转而使用更便宜、更灵活的DDR 高速网络连接：2x 200Gbps网络接口 高速包处理加速：P4可编程路径 加速器：用于加密、压缩和数据移动等 PCIe Gen4通道：32x PCIe Gen4通道和8个端口 安全和管理功能：Hardware RoT（Root of Trust），具有用于带外管理的1GbE接口 运行的操作系统：支持DPDK的Linux，以及VMware ESXi ","date":"2021-12-29","objectID":"/posts/dpu/:5:3","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"下一代DPU解决方案 Nvidia推出BlueField-2 DPU时，提出了未来三年DPU的路标。总体上来看，其核心是以400Gb/s的链路速度为代表的高速网络处理能力，以及更强的片上CPU处理能力。 目前，Nvidia已经发布了新一代DPU BlueField-3。它支持400Gbps网络，采用32通道PCIe Gen 5.0，搭载16核Armv8.2+ A78 CPU，具有16GB板载DDR5[7]，较上一代DPU性能实现了极大的提升。 ","date":"2021-12-29","objectID":"/posts/dpu/:5:4","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"六、工业界应用 ","date":"2021-12-29","objectID":"/posts/dpu/:6:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"亚马逊AWS Nitro系统 AWS的Nitro是DPU在云基础设施中应用的首批示例之一。Amazo Web Services分解了传统服务器，添加Nitro IO加速卡(ASIC)以通过整体Nitro卡控制器处理VPC（虚拟私有云）、EBS、实例存储、安全性等。Nitro将虚拟机管理程序、网络虚拟化和存储虚拟化任务分流到专用硬件，以释放主CPU。 AWS Elastic Compute Cloud实例基于PCIe连接的Nitro卡以及X86或Arm处理器和DRAM。有各种EC2实例类型—通用型或针对计算、内存、存储、机器学习和横向扩展用例进行了优化[8]。 ","date":"2021-12-29","objectID":"/posts/dpu/:6:1","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"七、总结 随着5G、大数据和云计算等新技术的蓬勃发展，数据中心的规模增大，基础架构需要的网络带宽不断提升。同时服务器物理核密度不断提高，支撑CPU的网络从25Gb/s增加到200Gb/s，服务器本身对网络基础功能的处理要求不断提高，在CPU内核上产生了过多的计算开销，这是DPU智能网卡产生的最关键原因之一。 DPU旨在卸载和基础网络处理相关的计算任务，利用各种硬件加速器，以比主机CPU更低的成本实现对各种网络功能和虚拟化的支持，进一步支持计算、存储、安全等方面的加速卸载，从而释放主机CPU的通用算力。 进一步，云服务提供商借助DPU实现各种计算、存储、网络资源的池化和按需分配，能够进一步提高资源的利用率，为数据中心降低成本，实现更高的经济效益。 ","date":"2021-12-29","objectID":"/posts/dpu/:7:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"Reference [1] Cadalyst Staff.What Is a DPU? The Third Pillar of Computing, Says NVIDIA [EB/OL]. (2020-5-20). https://www.cadalyst.com/design-related-technologies/graphics-cards-and-cpus/what-dpu-third-pillar-computing-says-nvidia-7585 [2] Premio Inc. What Is A DPU (Data Processing Unit)? [EB/OL]. (2021-5-12). https://premioinc.com/blogs/blog/what-is-a-dpu-data-processing-unit [3] 中国科学院计算技术研究所，鄢贵海等.专用数据处理器（DPU）技术白皮书[EB/OL]. (2021-10). http://www.yusur.tech/zkls/pdf/DPU-whitepaper-v1.0-final-21.pdf [4] KEVIN DEIERLING.What Is a DPU? [EB/OL].(2020-5-20). https://blogs.nvidia.com/blog/2020/05/20/whats-a-dpu-data-processing-unit/ [5] Patrick Kennedy What is a DPU A Data Processing Unit Quick Primer. [EB/OL]. (2020-9-29). https://www.servethehome.com/what-is-a-dpu-a-data-processing-unit-quick-primer/ [6] Patrick Kennedy. NVIDIA Shows DPU Roadmap Combining Arm Cores GPU and Networking [EB/OL]. (2020-10-5). https://www.servethehome.com/nvidia-shows-dpu-roadmap-combining-arm-cores-gpu-and-networking/ [7] NVIDIA Corporation.NVIDIA BLUEFIELD-3 DPU datasheet [EB/OL]. https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/documents/datasheet-nvidia-bluefield-3-dpu.pdf [8] AWS Events. Deep dive into the Nitro system[EB/OL]. (2019-12-10). https://www.youtube.com/watch?v=rUY-00yFlE4 [9] DPU家族大探秘：https://mp.weixin.qq.com/s/jmQG5uLjOlyIe-5QFL0PiQ ","date":"2021-12-29","objectID":"/posts/dpu/:8:0","tags":["DPU"],"title":"从DPU的产生与发展说起","uri":"/posts/dpu/"},{"categories":null,"content":"程序函数库可分为3种类型：静态函数库（static libraries）、共享函数库（shared libraries）、动态加载函数库（dynamically loaded libraries）： 静态函数库，是在程序执行前就加入到目标程序中去了； 共享函数库，则是在程序启动的时候加载到程序中，它可以被不同的程序共享；动态加载函数库则可以在程序运行的任何时候动态的加载。 动态函数库，并非另外一种库函数格式，区别是动态加载函数库是如何被程序员使用的。 GCC编译基础流程包括：预处理、编译、汇编、链接。 ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:0:0","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"静态链接 链接器在链接时将库的内容加入到可执行程序中 静态函数库实际上就是简单的一个普通的目标文件的集合，一般来说习惯用“.a”作为文件的后缀。可以用ar这个程序来产生静态函数库文件 静态函数库现在已经不在像以前用得那么多了，主要是共享函数库与之相比较有很多的优势的原因。 静态库函数允许把程序link起来而不用重新编译代码，节省了重新编译代码的时间。 把自己提供的函数给别人使用，但是又想对函数的源代码进行保密，就可以提供一个静态函数库文件。 ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:1:0","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"静态函数库（静态链接库）：程序编译时使用 扩展名：.a（archive） 命名格式：libxxx.a 独立执行：编译成功的可执行文件可以独立执行 ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:1:1","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"demo： ./lib/sqrt.h extern int sqrt(int i); ./lib/sqrt.cpp #include\"sqrt.h\" int sqrt(int i ){return i*i;} #gcc -c sqrt.cpp #ar rcs libmylib.a sqrt.o #注意命名方式 以lib开头 .a结束 ./\"test.cpp\" #include\u003ciostream\u003e extern int sqrt(int i); int main(){ std::cout \u003c\u003c sqrt(100) \u003c\u003cstd::endl ; return 0; } #g++ -o test.cpp -L ./lib -l mylib #当libmylib.c在同一目录下时 直接 g++ -o test.cpp libmylib.a 上述编译过程都没有加入-static选项，所以默认都是采用动态链接（dynamically linked）。加上-static后才是静态链接（statically linked）的。用静态库既可以实现静态链接也可以实现动态链接。 ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:1:2","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"动态链接 链接器在链接时仅仅建立与所需库函数之间的链接关系，在程序运行时才将所需资源调入可执行程序中 动态链接库，在Linux下是.so文件，在编译链接时只需要记录需要链接的号，运行程序时才会进行真正的“链接”，所以称为“动态链接”。 如果同一台机器上有多个服务使用同一个动态链接库，则只需要加载一份到内存中共享。因此，动态链接库也称共享库。 ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:2:0","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"命名规则 动态链接库与应用程序之间的真正链接是在应用程序运行时，因此很容易出现开发环境和运行环境的动态链接库不兼容或缺失的情况。 Linux通过规定动态链接库的版本命名规则来管理兼容性问题。 Linux规定动态链接库的文件名规则比如如下： libname.so.x.y.z lib：统一前缀。 so：统一后缀。 name：库名，如libstdc++.so.6.0.21的name就是stdc++。 x：主版本号。表示库有重大升级，不同主版本号的库之间是不兼容的。如libstdc++.so.6.0.21的主版本号是6。 y：次版本号。表示库的增量升级，如增加一些新的接口。在主版本号相同的情况下，高的次版本号向后兼容低的次版本号。如libstdc++.so.6.0.21的次版本号是0。 z：发布版本号。表示库的优化、bugfix等。相同的主次版本号，不同的发布版本号的库之间完全兼容。如libstdc++.so.6.0.21的发布版本号是21。 另外，Linux下的一个动态链接库会有下面三个名字： libstdc++.so -\u003e libstdc++.so.6.0.21* libstdc++.so.6 -\u003e libstdc++.so.6.0.21* libstdc++.so.6.0.21* libstdc++.so：linker name，程序编译链接时如果依赖了共享库，链接器只认不带任何版本的共享库。如果存在多个同名（上面命名规则中的name）动态链接库，linker name会指向最新的一个。 libstdc++.so.6：SO_NAME， 程序运行时会按照这个名称去找真正的库文件。也就是说，ELF可执行文件中保存的动态库名就是SO_NAME。如果存在多个同一主版本号的动态链接库，SO_NAME会指向最新的一个。 libstdc++.so.6.0.21：real name，这是动态链接库的真正名称。 ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:2:1","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"动态函数库（动态链接库）：程序运行时使用 扩展名：.so (shared object) 命名格式：libxxx.so 独立执行：编译成功的可执行文件不可独立执行，库函数文件必须要存在，并且函数库所在目录也不能改变 注：使用gcc hello.c -o hello时，系统默认使用动态链接方式进行编译程序，若想使用静态编译，需加入-static参数 如果静态库、动态库都放在/lib下，当静态库函数与动态库函数重名时，系统也是优先考虑链接动态库，同样如果想要使用静态库，需加入-static选项 demo: ./\"arith.h\" #pragma once int add(int a, int b); ./\"arith.c” #include \"arith.h\" int add(int a, int b) { return a + b; } #gcc -fPIC -shared arith.cpp -o libarith.so ./\"main.cpp\" #include \"arith.h\" int main() { add(1, 2); } 如果我们不指定rpath直接编译main.c： $ gcc -L. -larith main.c -o main 若此时运行main文件会报如下错误： ./main: error while loading shared libraries: libarith.so: cannot open shared object file: No such file or directory 报错提示找不到libarith.so文件。该文件在我们当前目录下，但是当前目录并不在运行时链接器的搜索路径中。一种解决办法是将当前路径添加到LD_LIBRARY_PATH中，但是该方法是一种全局配置，总是显得不那么干净。下面介绍第二种方法，就是在链接的时候直接将搜索路径写到RPATH中，按如下方式重新编译： $ gcc -L. -larith main.c -Wl,-rpath='.' -o main -rpath是链接器选项，并不是gcc的编译选项，所以上面通过-Wl,告知编译器将此选项传给下一阶段的链接器。重新编译后，采用readelf命令查看main文件的dynamic节，发现多了一个RPATH字段，且值就是我们前面设置的路径。 $ readelf -d main| grep PATH 0x000000000000000f (RPATH) Library rpath: [.] 再次尝试运行main文件会发现一切正常。 $ORIGIN 上面的解决办法还有一些小问题，RPATH指定的路径是相当于当前目录的，而不是相对于可执行文件所在的目录，那么当换一个目录再执行上面的程序，就会又报找不到共享库。解决这个问题的办法就是使用$ORIGIN变量，在运行的时候，链接器会将该变量的值用可执行文件所在的目录来替换，这样我们就又能相对于可执行文件来指定RPATH了。重新编译如下： $ gcc -L. -larith main.c -Wl,-rpath='$ORIGIN/' -o main ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:2:2","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"相关路径 /lib：最关键和基础的动态链接库。 /usr/lib：关键的动态链接库。 /usr/local/lib：第三方动态链接库。 由/etc/ld.so.conf配置文件指定的目录。 ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:3:0","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"ldconfig 动态链接器不可能在每次查找动态链接库都去遍历所有动态链接库的目录，这样速度太慢了。因此，在系统启动时会通过ldconfig为动态链接库生成SO_NAME和/etc/ld.so.cache存放系统动态链接库的路径信息，加速动态链接库的查找。 程序启动查找动态链接库的路径顺序如下： 由LD_LIBRARY_PATH指定的路径。 由路径缓存文件/etc/ld.so.cache指定的路径。 默认共享库目录，先/usr/lib，然后/lib。 注意，安装动态链接库后，需要重启系统或运行ldconfig生成SO_NAME和刷新/etc/ld.so.cache文件。 ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:4:0","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"ldd 通过ldd elf_file可以查看ELF文件依赖哪些动态链接库，如 ldd a linux-vdso.so.1 =\u003e (0x00007fffc5bfe000) libmylib.so =\u003e not found libstdc++.so.6 =\u003e /lib64/libstdc++.so.6 (0x00007f258d42d000) libm.so.6 =\u003e /lib64/libm.so.6 (0x00007f258d12b000) libgcc_s.so.1 =\u003e /lib64/libgcc_s.so.1 (0x00007f258cf15000) libc.so.6 =\u003e /lib64/libc.so.6 (0x00007f258cb47000) /lib64/ld-linux-x86-64.so.2 (0x00007f258d734000) linux-vdso.so.1是内核提供的一个动态链接库，所以这里只有一个内存地址。 /lib64/ld-linux-x86-64.so.2是一个动态链接库的绝对路径。 ","date":"2020-07-02","objectID":"/posts/linux%E9%93%BE%E6%8E%A5/:5:0","tags":["Linux"],"title":"linux链接相关","uri":"/posts/linux%E9%93%BE%E6%8E%A5/"},{"categories":null,"content":"rpath全称是run-time search path。Linux下所有elf格式的文件都包含它，特别是可执行文件。它规定了可执行文件在寻找.so文件时的第一优先位置。 另外，elf文件中还规定了runpath。它与rpath相同，只是优先级低一些。 搜索.so的优先级顺序 编译目标代码时指定的动态库搜索路径； 如果在编译程序时增加参数-Wl,-rpath=’.’ , 这时生成程序的Dynamic section会新加一个RPATH段 环境变量LD_LIBRARY_PATH指定的动态库搜索路径； ( 可用export LD_LIBRARY_PATH=“NEWDIRS” 命令添加临时环境变量 ) RUNPATH： 写在elf文件中 ldconfig的缓存：配置文件/etc/ld.so.conf中指定的动态库搜索路径；(系统默认情况下未设置) 默认的动态库搜索路径/lib； 默认的动态库搜索路径/usr/lib； RPATH与RUNPATH中间隔着LD_LIBRARY_PATH，可以通过修改LD_LIBRARY_PATH来指定.so文件，大多数编译器都将输出的RPATH留空，并用RUNPATH代替RPATH。 查看RPATH 对于任意的elf文件，可以使用$ readelf -d filename | grep PATH 来查看。 0x000000000000001d (RUNPATH) Library runpath: [$ORIGIN/] 结果有两类，一个是RPATH，另一个是RUNPATH。一般情况下，RPATH为空，而RUNPATH不为空。 RPATH中有个特殊的标识符$ORIGIN。这个标识符代表elf文件自身所在的目录。 当希望使用相对位置寻找.so文件，就需要利用$ORIGIN设置RPATH。多个路径之间使用冒号:隔开。 设置RPATH 在gcc中，设置RPATH的办法很简单，就是设置linker的rpath选项： gcc -L. -larith main.c -Wl,-rpath=’.’ -o main （-Wl参数意思是把rpath选项传递到链接阶段） 如果需要设置$ORIGIN：$ gcc -Wl,-rpath,’$ORIGIN/lib’ test.cpp。 注意，虽然选项里写着RPATH，但它设置的还是RUNPATH。原因在前文有交代。 在CMake中，使用变量来控制RPATH：INSTALL_RPATH和BUILD_RPATH。 设置的办法是：SET_TARGET_PROPERTIES(target PROPERTIES INSTALL_RPATH “$ORIGIN;/another/run/path”) （cmake中多个RPATH使用分号隔开） ","date":"2020-07-02","objectID":"/posts/rpath%E5%92%8Cpatchelf/:0:0","tags":["Linux"],"title":"rpath和patchelf","uri":"/posts/rpath%E5%92%8Cpatchelf/"},{"categories":null,"content":"patchelf patchelf 是一个用来修改elf格式的动态库和可执行程序的小工具，可以修改动态链接库的库名字，以及链接库的RPATH。 打印出动态库的soname patchelf –print-soname xxx.so 修改动态库的soname patchelf –set-soname oldxxx.so newxxx.so 查看并修改第三方依赖库 patchelf –print-needed xxx.so patchelf –replace-needed oldxxx.so newxxx.so this.so 修改rpath patchelf –set-rpath ‘$ORIGIN/’ main ","date":"2020-07-02","objectID":"/posts/rpath%E5%92%8Cpatchelf/:1:0","tags":["Linux"],"title":"rpath和patchelf","uri":"/posts/rpath%E5%92%8Cpatchelf/"},{"categories":null,"content":"第 1 步，启用 WSL 以管理员身份打开 PowerShell 工具并运行以下命令 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:1","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"第 2 步，启用“虚拟机平台” WSL 2 需要启用 Windows 10 的 “虚拟机平台” 特性。它独立于 Hyper-V，并提供了一些在 Linux 的 Windows 子系统新版本中可用的更有趣的平台集成。 要在 Windows 10（2004）上启用虚拟机平台，以管理员身份打开 PowerShell 并运行： dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 要在 Windows 10（1903，1909）上启用虚拟机平台，请以管理员身份打开 PowerShell 并运行： Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform -NoRestart 重启系统 ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:2","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"第 3 步，更新内核组件 wsl_update_x64.exe ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:3","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"第 4步，设置 WSL 2 为默认值 以管理员身份打开 PowerShell，然后运行以下命令以将 WSL 2 设置为 WSL 的默认版本： wsl --set-default-version 2 ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:4","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"第 5 步，安装 Linux 发行版 从 Microsoft Store 中选择并安装 Linux 发行版 有几种不同的发行版可供选择，包括 OpenSUSE、Pengwin、Fedora Remix 和 Alpine Linux。 个人推荐Ubuntu 20.04 LTS（尽管也有 18.04 LTS 和 16.04 LTS 可用）。 要在 Windows 10 上安装 Ubuntu，请打开 Microsoft Store 应用，搜索 “Ubuntu 20.04”。 wsl.exe --set-version Ubuntu 2 ","date":"2020-06-27","objectID":"/posts/wsl%E5%AE%89%E8%A3%85/:0:5","tags":["Linux"],"title":"Windows WSL安装","uri":"/posts/wsl%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"不稳定排序算法 [堆排序]、[快速排序]、[希尔排序]、[直接选择排序] 稳定排序算法 [基数排序]、[冒泡排序]、[直接插入排序]、[折半插入排序]、[归并排序] ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:0","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"1.冒泡排序 void bubble_sort(vector\u003cint\u003e \u0026arry){ for(int i = 0 ;i\u003c array.size()-1 ; i++){ int index = 0 ; for(int j = 0; j \u003c array.size()- 1 - i ;j ++){ if(array[j] \u003e array[j+1]) swap(array[j],array[j+1]); } } } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:1","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"2.选择排序 void select_sort(vector\u003cint\u003e \u0026arry){ for(int i = 0 ;i\u003c array.size();i++){ int index = i ; for(int j = i+ 1; j\u003c array.size(); j++) if(array[j]\u003carray[index]) index = j; } swap(array[index],array[i]); } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:2","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"3.插入排序(简单插入排序) void insert_sort(vector\u003cint\u003e \u0026arry){ for(int i = 1;i\u003c array.size();i++){ int index = i-1; int cur = array[i]; while(index \u003e=0 \u0026\u0026 array[i]\u003carray[index]) { array[index+1]=array[index]; index -- ; } array[index+1] = cur; } } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:3","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"4.希尔排序 void shell_sort(vector\u003cint\u003e \u0026array){ int n = array.size(); for(int gap = n/2 ; gap \u003e 0; gap /=2){ for(int i = gap;i\u003c n ;i++){ insert(array,gap,i); } } } void insert(vector\u003cint\u003e \u0026array, int gap, int i){ int inserted = array[i]; int j; for(int j = i-gap; j\u003e=0 \u0026\u0026 inserted \u003c array[j]; j-= gap) array[j+gap] = array[j]; array[j+gap] = inserted; } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:4","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"5.快速排序 void quick_sort(vector\u003cint\u003e \u0026arry, int left ,int right){ if(left \u003c right){ int p = partition(array,left,right); quick_sort(array,left,p-1); quick_sort(array,p+1,right); } } int partition(vector\u003cint\u003e \u0026arry, int left ,int right){ int p = left; int index = p+1; for(int i = index ; i\u003c=right;i++){ if(array[i]\u003carray[index]){ swap(array[i],array[index]); index++; } } swap(array[p],array[index-1]); return index-1; } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:5","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"6.归并排序 void merge_sort(vector\u003cint\u003e \u0026array,int left,int right){ if(left\u003cright){ int mid = left + (right - left) \u003e\u003e 1; merge_sort(array,left,mid); merge_sort(array,mid+1,right); merge(array,left,mid,right); } } void merge(vector\u003cint\u003e \u0026array,int left,int mid ,int right){ int * tmp = new int[right - left + 1]; int i = left; int j = mid+1; int index = 0; while(i\u003c=mid \u0026\u0026 j\u003c= right) tmp[index++] = array[i]\u003carray[j]?array[i++]:array[j++]; while(i\u003c=mide) tmp[index++] = array[i++]; while(j\u003c=right) tmp[index++] = array[j++]; for(int i = 0 ;i\u003c right - left +1 ; i++) array[left + i] = tmp[i]; delete tmp; } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:6","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"7.堆排序 void heap_sort(vector\u003cint\u003e \u0026array,int size){ //构建大根堆 for(int i = size/2 -1 ; i\u003e=0 ;i--) adjust_heap(array,size,i); //调整大根堆 for(int i = size - 1;i\u003e = 1; i--){ swap(array[0],array[i]);// 将当前最大的放置到数组末尾 adjust(array,i,0); //将未完成排序的部分继续进行堆排序 } } void adjust_heap(vector\u003cint\u003e \u0026array, int len, int index){ //len是array的长度，index是第一个非叶子节点的下标 if(index \u003e len) return; int leftc = 2*index + 1; int rightc = 2*index + 2; int maxindex = index; if(leftc \u003c len \u0026\u0026 array[leftc] \u003e array[maxindex]) maxindex = leftc; if(rightc \u003c len \u0026\u0026 array[right] \u003e array[maxinnex]) maxindex = rightc; if(maxindex != index){ swap(array[idnex],array[maxindex]); adjust_heap(array,len,maxindex); } } ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:7","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"8.计数排序 ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:8","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"9.基数排序 ","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:9","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"10.桶排序","date":"2020-06-20","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/:0:10","tags":["algorithm","sort"],"title":"排序算法总结","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"前序遍历 void preorder(Node * head){ if(head!=null) { cout \u003c\u003c head -\u003e val; preorder(head-\u003eleft); preorder(head-\u003eright); } } void preorder(Node * head){ if(!head) return ; stack\u003cNode *\u003e s; s.push(head); while(!s.empty()){ Node * tmp = s.top(); s.pop(); cout \u003c\u003c tmp.val; if(tmp-\u003eleft) s.push(tmp-\u003eleft); if(tmp-\u003eright) s.push(tmp-\u003eright); } } 中序遍历 void inorder(Node * head){ if(head!=null) { inorder(head-\u003eleft); cout \u003c\u003c head -\u003e val; inorder(head-\u003eright); } } void inorder(Node * head){//一直将他的左子树压栈。 一直到左子树最左的节点 if(!head) return ; stack\u003cNode*\u003e s; s.push(head); while(!s.empty() || head!=nullptr){ if(head-\u003eleft!=nullptr) s.push(head-\u003eleft); else{ head = s.top(); s.pop(); cout \u003c\u003c head-\u003eval; if(head-\u003eright!=nullptr) s.push(head.right); } } } 后序遍历 void laterorder(Node * head){ if(head!=null) { laterorder(head-\u003eleft); laterorder(head-\u003eright); cout \u003c\u003c head -\u003e val; } } void laterorder(Node * head){//维护两个栈，第一个栈遍历顺序 中右左; 第二个 左右中。 if(!head) return ; stack\u003cNode * \u003e s1,s2; s1.push(head); while(!s1.empty()){ head = s1.top(); s1.pop(); s2.push(head); if(head-\u003eleft) s1.push(head-\u003eleft); if(head-\u003eright) s1.push(head-\u003eright); } while(!s2.empty()){ head = s2.top(); s2.pop(); cout \u003c\u003c head-\u003eval; } } ","date":"2020-03-29","objectID":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["algorithm","tree"],"title":"二叉树遍历","uri":"/posts/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":null,"content":" IVR (Interactive Voice Response )：交互式语音应答 ASR (Automatic Speech Recognition）将人的语音转换为文本的技术 PSTN (Public Switched Telephone Network)：公共交换电话网，即我们日常使用的电话网 SIP (Session Initiation Protocol)：SIP协议用于创建，修改和终止包括视频，语音，即时通信等多种多媒体元素在内的交互式用户会话 RTP(Real-time Transport Protocol): 为实时传输交互的音频和视频提供了端到端传输服务 MRCP(Media Resource Control Protocol)，一种通讯协议，用于语音服务器向客户端提供各种语音服务（如：语音识别，语音合成，声纹识别，录音服务等），类似于 HTTP，MRCP使用请求（通常由客户端发起）、响应模式。响应可以简单的确认请求，或者给出关于处理的其它信息。例如，MRCP客户端向服务端请求想要发送一些音频数据以进行处理（比如说语音识别），为此，服务端可以发送一个包含端口号的响应，因为MRCP并未定义音频数据的传输，所以，必须依靠其它的协议，比如说RTP 来进行。 VoIP(Voice over IP)：网络（IP）电话 PBX (Private Branch Exchange)：专用小型交换机，常用于公司内部电话通讯。 AD转换（Analog-to-digital converter）：用于将模拟形式的连续信号转换为数字形式的离散信号的一类设备 DA转换：与AD转化作用相反 SPAN（Switched Port Analyzer）：一种交换机的端口镜像技术。在三层交换机上有一个特殊的SPAN端口，不会影响源端口的数据交换，只是将源端口发送或接收的数据包副本发送到监控端口。 SIP 交换过程： 对音频进行编码常见的格式： 音频编码：入门看这篇就够了丨音视频基础 - 知乎 PCM，无压缩。一种将模拟信号的数字化方法，无损编码。 WAV，无压缩。有多种实现方式，但是都不会进行压缩操作。其中一种实现就是在 PCM 数据格式的前面加上 44 字节，分别用来描述 PCM 的采样率、声道数、数据格式等信息。音质非常好，大量软件都支持。 MP3，有损压缩。音质在 128 Kbps 以上表现还不错，压缩比比较高，大量软件和硬件都支持，兼容性好。 AAC，有损压缩。在小于 128 Kbps 的码率下表现优异，并且多用于视频中的音频编码。 OPUS，有损压缩。可以用比 MP3 更小的码率实现比 MP3 更好的音质，高中低码率下均有良好的表现，兼容性不够好，流媒体特性不支持。适用于语音聊天的音频消息场景。 WebRTC 技术简介 WebRTC简介 - 知乎 WebRTC简介 | John520 ","date":"0001-01-01","objectID":"/posts/%E5%91%BC%E5%8F%AB%E4%B8%AD%E5%BF%83%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/:0:0","tags":["Call Center"],"title":"呼叫中心术语记录","uri":"/posts/%E5%91%BC%E5%8F%AB%E4%B8%AD%E5%BF%83%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"}]